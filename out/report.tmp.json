[{"type":"paragraph","text":"Transfer Success"},{"type":"code","lang":"act","obj":{"isStatic":false,"name":"transfer","subject":"StandardToken","varname2alias":{"ACCT_ID":"StandardToken"},"act_name":"StandardToken_transfer.act","internal":false,"sig":"transfer(address,uint256)","callData":"#abiCallData(\"transfer\", #address(ABI__to), #uint256(ABI__value)) ++ CD","signature":"transfer(address,uint256)","types":{"ABI__to":"address","ABI__value":"uint256","FromBal":"uint256","ToBal":"uint256"},"if":["(#sizeWordStack(CD) <=Int 1250000000)","(FromBal >=Int ABI__value)","(ABI__value >Int 0)","(CALLER_ID =/=Int ABI__to)"],"interface":[["address","_to"],["uint256","_value"]],"fname":"transfer","storage":{"ACCT_ID":{"balances[CALLER_ID]":["FromBal","FromBal - _value"],"balances[_to]":["ToBal  ","ToBal + _value"]}},"iff":["((#rangeUInt(256, FromBal -Int ABI__value)))","((#rangeUInt(256, ToBal +Int ABI__value)))","(VCallValue ==Int 0)"],"iff_orig":["VCallValue == 0"],"if_orig":["FromBal >= _value","_value > 0","CALLER_ID =/= _to"],"returns":["1"]},"cases":[{"act":{"isStatic":false,"name":"transfer","subject":"StandardToken","varname2alias":{"ACCT_ID":"StandardToken"},"act_name":"StandardToken_transfer.act","internal":false,"sig":"transfer(address,uint256)","callData":"#abiCallData(\"transfer\", #address(ABI__to), #uint256(ABI__value)) ++ CD","signature":"transfer(address,uint256)","types":{"ABI__to":"address","ABI__value":"uint256","FromBal":"uint256","ToBal":"uint256"},"if":["(#sizeWordStack(CD) <=Int 1250000000)","(FromBal >=Int ABI__value)","(ABI__value >Int 0)","(CALLER_ID =/=Int ABI__to)"],"interface":[["address","_to"],["uint256","_value"]],"fname":"transfer","storage":{"ACCT_ID":{"balances[CALLER_ID]":["FromBal","FromBal - _value"],"balances[_to]":["ToBal  ","ToBal + _value"]}},"iff":["((#rangeUInt(256, FromBal -Int ABI__value)))","((#rangeUInt(256, ToBal +Int ABI__value)))","(VCallValue ==Int 0)"],"iff_orig":["VCallValue == 0"],"if_orig":["FromBal >= _value","_value > 0","CALLER_ID =/= _to"],"returns":["1"]},"name":"StandardToken_transfer_pass_rough","pass":true,"rough":true,"oog":false,"splitNumber":-1,"gas":[3000000],"hasGas":false,"spec":"// StandardToken_transfer\nrule [StandardToken.transfer.pass.rough]:\n  <k> #execute ~> CONTINUATION => #halt ~> CONTINUATION </k>\n  <exit-code> 1 </exit-code>\n  <mode> NORMAL </mode>\n  <schedule> PETERSBURG </schedule>\n  <ethereum>\n    <evm>\n      <output> _ => #asByteStackInWidthaux(1, 31, 32, .WordStack) </output>\n      <statusCode> _ => EVMC_SUCCESS </statusCode>\n      <callStack> VCallStack </callStack>\n      <interimStates> _ </interimStates>\n      <touchedAccounts> _ => _ </touchedAccounts>\n      <callState>\n        <program> #asMapOpCodes(#dasmOpCodes(StandardToken_bin_runtime, PETERSBURG)) </program>\n        <programBytes> StandardToken_bin_runtime </programBytes>\n        <id> ACCT_ID </id>\n        <caller> CALLER_ID </caller>\n        <callData> #abiCallData(\"transfer\", #address(ABI__to), #uint256(ABI__value)) ++ CD => _ </callData>\n        <callValue> VCallValue </callValue>\n        <wordStack> .WordStack => _ </wordStack>\n        <localMem> .Map => _ </localMem>\n        <pc> 0 => _ </pc>\n        <gas> VGas => _ </gas>\n        <memoryUsed> 0 => _ </memoryUsed>\n        <callGas> _ => _ </callGas>\n        <static> false </static>\n        <callDepth> VCallDepth </callDepth>\n      </callState>\n      <substate>\n        <selfDestruct> VSelfDestruct </selfDestruct>\n        <log> _ => VLog </log>\n        <refund> _ => VRefund </refund>\n      </substate>\n      <gasPrice> _ </gasPrice>\n      <origin> ORIGIN_ID </origin>\n      <previousHash> _ </previousHash>\n      <ommersHash> _ </ommersHash>\n      <coinbase> _ </coinbase>\n      <stateRoot> _ </stateRoot>\n      <transactionsRoot> _ </transactionsRoot>\n      <receiptsRoot> _ </receiptsRoot>\n      <logsBloom> _ </logsBloom>\n      <difficulty> _ </difficulty>\n      <number> _ </number>\n      <gasLimit> _ </gasLimit>\n      <gasUsed> _ </gasUsed>\n      <timestamp> TIME </timestamp>\n      <extraData> _ </extraData>\n      <mixHash> _ </mixHash>\n      <blockNonce> _ </blockNonce>\n      <ommerBlockHeaders> _ </ommerBlockHeaders>\n      <blockhash> _ </blockhash>\n    </evm>\n    <network>\n      <activeAccounts> SetItem(ACCT_ID)\n      SetItem(1)\n      SetItem(2)\n      SetItem(3)\n      SetItem(4)\n      SetItem(5)\n      SetItem(6)\n      SetItem(7)\n      SetItem(8) _ </activeAccounts>\n      <accounts>\n        <account>\n          <acctID> ACCT_ID </acctID>\n          <balance> ACCT_ID_balance </balance>\n          <code> StandardToken_bin_runtime </code>\n          <storage>         \n           .Map \n          [#StandardToken.balances[CALLER_ID] <- (FromBal => FromBal -Int ABI__value)]        \n          [#StandardToken.balances[ABI__to] <- (ToBal   => ToBal +Int ABI__value)]\n            _:Map \n           </storage>\n          <origStorage> _ </origStorage>\n          <nonce> _ </nonce>\n        </account>\n        <account>\n          <acctID> 1 </acctID>\n          <balance> ECREC_BAL </balance>\n          <code> .WordStack </code>\n          <storage> _:Map </storage>\n          <origStorage> _ </origStorage>\n          <nonce> _ </nonce>\n        </account>\n        <account>\n          <acctID> 2 </acctID>\n          <balance> SHA256_BAL </balance>\n          <code> .WordStack </code>\n          <storage> _:Map </storage>\n          <origStorage> _ </origStorage>\n          <nonce> _ </nonce>\n        </account>\n        <account>\n          <acctID> 3 </acctID>\n          <balance> RIP160_BAL </balance>\n          <code> .WordStack </code>\n          <storage> _:Map </storage>\n          <origStorage> _ </origStorage>\n          <nonce> _ </nonce>\n        </account>\n        <account>\n          <acctID> 4 </acctID>\n          <balance> ID_BAL </balance>\n          <code> .WordStack </code>\n          <storage> _:Map </storage>\n          <origStorage> _ </origStorage>\n          <nonce> _ </nonce>\n        </account>\n        <account>\n          <acctID> 5 </acctID>\n          <balance> MODEXP_BAL </balance>\n          <code> .WordStack </code>\n          <storage> _:Map </storage>\n          <origStorage> _ </origStorage>\n          <nonce> _ </nonce>\n        </account>\n        <account>\n          <acctID> 6 </acctID>\n          <balance> ECADD_BAL </balance>\n          <code> .WordStack </code>\n          <storage> _:Map </storage>\n          <origStorage> _ </origStorage>\n          <nonce> _ </nonce>\n        </account>\n        <account>\n          <acctID> 7 </acctID>\n          <balance> ECMUL_BAL </balance>\n          <code> .WordStack </code>\n          <storage> _:Map </storage>\n          <origStorage> _ </origStorage>\n          <nonce> _ </nonce>\n        </account>\n        <account>\n          <acctID> 8 </acctID>\n          <balance> ECPAIRING_BAL </balance>\n          <code> .WordStack </code>\n          <storage> _:Map </storage>\n          <origStorage> _ </origStorage>\n          <nonce> _ </nonce>\n        </account>\n       ... \n      </accounts>\n      <txOrder> _ </txOrder>\n      <txPending> _ </txPending>\n      <messages> _ </messages>\n    </network>\n  </ethereum>\nrequires #rangeAddress(ACCT_ID)\nandBool #notPrecompileAddress(ACCT_ID)\nandBool #rangeAddress(CALLER_ID)\nandBool #rangeAddress(ORIGIN_ID)\nandBool #rangeUInt(256, TIME)\nandBool #rangeUInt(256, ACCT_ID_balance)\nandBool #rangeUInt(256, ECREC_BAL)\nandBool #rangeUInt(256, SHA256_BAL)\nandBool #rangeUInt(256, RIP160_BAL)\nandBool #rangeUInt(256, ID_BAL)\nandBool #rangeUInt(256, MODEXP_BAL)\nandBool #rangeUInt(256, ECADD_BAL)\nandBool #rangeUInt(256, ECMUL_BAL)\nandBool #rangeUInt(256, ECPAIRING_BAL)\nandBool VCallDepth <=Int 1024\nandBool #rangeUInt(256, VCallValue)\n\n  andBool (#rangeAddress(ABI__to)\n  andBool (#rangeUInt(256, ABI__value)\n  andBool (#rangeUInt(256, FromBal)\n  andBool (#rangeUInt(256, ToBal)\n  andBool ((#sizeWordStack(CD) <=Int 1250000000)\n  andBool ((FromBal >=Int ABI__value)\n  andBool ((ABI__value >Int 0)\n  andBool ((CALLER_ID =/=Int ABI__to)\n  andBool (VGas >=Int 3000000\n  andBool (((#rangeUInt(256, FromBal -Int ABI__value)))\n  andBool (((#rangeUInt(256, ToBal +Int ABI__value)))\n  andBool ((VCallValue ==Int 0))))))))))))) ","v2n":{"ACCT_ID":"StandardToken"},"act_name":"StandardToken_transfer.act","imports":[],"closed":true,"ctx":[],"module":"requires \"../rules.k\"\nrequires \"../bin_runtime.k\"\n\nmodule 82A642201AD8FB6A586C9475410CA211FB44D3A8189D3AE4116D6147090E403D\n  imports ETHEREUM-SIMULATION\n  imports EVM\n  imports RULES\n  imports BIN_RUNTIME\n\n// StandardToken_transfer\nrule [StandardToken.transfer.pass.rough]:\n  <k> #execute ~> CONTINUATION => #halt ~> CONTINUATION </k>\n  <exit-code> 1 </exit-code>\n  <mode> NORMAL </mode>\n  <schedule> PETERSBURG </schedule>\n  <ethereum>\n    <evm>\n      <output> _ => #asByteStackInWidthaux(1, 31, 32, .WordStack) </output>\n      <statusCode> _ => EVMC_SUCCESS </statusCode>\n      <callStack> VCallStack </callStack>\n      <interimStates> _ </interimStates>\n      <touchedAccounts> _ => _ </touchedAccounts>\n      <callState>\n        <program> #asMapOpCodes(#dasmOpCodes(StandardToken_bin_runtime, PETERSBURG)) </program>\n        <programBytes> StandardToken_bin_runtime </programBytes>\n        <id> ACCT_ID </id>\n        <caller> CALLER_ID </caller>\n        <callData> #abiCallData(\"transfer\", #address(ABI__to), #uint256(ABI__value)) ++ CD => _ </callData>\n        <callValue> VCallValue </callValue>\n        <wordStack> .WordStack => _ </wordStack>\n        <localMem> .Map => _ </localMem>\n        <pc> 0 => _ </pc>\n        <gas> VGas => _ </gas>\n        <memoryUsed> 0 => _ </memoryUsed>\n        <callGas> _ => _ </callGas>\n        <static> false </static>\n        <callDepth> VCallDepth </callDepth>\n      </callState>\n      <substate>\n        <selfDestruct> VSelfDestruct </selfDestruct>\n        <log> _ => VLog </log>\n        <refund> _ => VRefund </refund>\n      </substate>\n      <gasPrice> _ </gasPrice>\n      <origin> ORIGIN_ID </origin>\n      <previousHash> _ </previousHash>\n      <ommersHash> _ </ommersHash>\n      <coinbase> _ </coinbase>\n      <stateRoot> _ </stateRoot>\n      <transactionsRoot> _ </transactionsRoot>\n      <receiptsRoot> _ </receiptsRoot>\n      <logsBloom> _ </logsBloom>\n      <difficulty> _ </difficulty>\n      <number> _ </number>\n      <gasLimit> _ </gasLimit>\n      <gasUsed> _ </gasUsed>\n      <timestamp> TIME </timestamp>\n      <extraData> _ </extraData>\n      <mixHash> _ </mixHash>\n      <blockNonce> _ </blockNonce>\n      <ommerBlockHeaders> _ </ommerBlockHeaders>\n      <blockhash> _ </blockhash>\n    </evm>\n    <network>\n      <activeAccounts> SetItem(ACCT_ID)\n      SetItem(1)\n      SetItem(2)\n      SetItem(3)\n      SetItem(4)\n      SetItem(5)\n      SetItem(6)\n      SetItem(7)\n      SetItem(8) _ </activeAccounts>\n      <accounts>\n        <account>\n          <acctID> ACCT_ID </acctID>\n          <balance> ACCT_ID_balance </balance>\n          <code> StandardToken_bin_runtime </code>\n          <storage>         \n           .Map \n          [#StandardToken.balances[CALLER_ID] <- (FromBal => FromBal -Int ABI__value)]        \n          [#StandardToken.balances[ABI__to] <- (ToBal   => ToBal +Int ABI__value)]\n            _:Map \n           </storage>\n          <origStorage> _ </origStorage>\n          <nonce> _ </nonce>\n        </account>\n        <account>\n          <acctID> 1 </acctID>\n          <balance> ECREC_BAL </balance>\n          <code> .WordStack </code>\n          <storage> _:Map </storage>\n          <origStorage> _ </origStorage>\n          <nonce> _ </nonce>\n        </account>\n        <account>\n          <acctID> 2 </acctID>\n          <balance> SHA256_BAL </balance>\n          <code> .WordStack </code>\n          <storage> _:Map </storage>\n          <origStorage> _ </origStorage>\n          <nonce> _ </nonce>\n        </account>\n        <account>\n          <acctID> 3 </acctID>\n          <balance> RIP160_BAL </balance>\n          <code> .WordStack </code>\n          <storage> _:Map </storage>\n          <origStorage> _ </origStorage>\n          <nonce> _ </nonce>\n        </account>\n        <account>\n          <acctID> 4 </acctID>\n          <balance> ID_BAL </balance>\n          <code> .WordStack </code>\n          <storage> _:Map </storage>\n          <origStorage> _ </origStorage>\n          <nonce> _ </nonce>\n        </account>\n        <account>\n          <acctID> 5 </acctID>\n          <balance> MODEXP_BAL </balance>\n          <code> .WordStack </code>\n          <storage> _:Map </storage>\n          <origStorage> _ </origStorage>\n          <nonce> _ </nonce>\n        </account>\n        <account>\n          <acctID> 6 </acctID>\n          <balance> ECADD_BAL </balance>\n          <code> .WordStack </code>\n          <storage> _:Map </storage>\n          <origStorage> _ </origStorage>\n          <nonce> _ </nonce>\n        </account>\n        <account>\n          <acctID> 7 </acctID>\n          <balance> ECMUL_BAL </balance>\n          <code> .WordStack </code>\n          <storage> _:Map </storage>\n          <origStorage> _ </origStorage>\n          <nonce> _ </nonce>\n        </account>\n        <account>\n          <acctID> 8 </acctID>\n          <balance> ECPAIRING_BAL </balance>\n          <code> .WordStack </code>\n          <storage> _:Map </storage>\n          <origStorage> _ </origStorage>\n          <nonce> _ </nonce>\n        </account>\n       ... \n      </accounts>\n      <txOrder> _ </txOrder>\n      <txPending> _ </txPending>\n      <messages> _ </messages>\n    </network>\n  </ethereum>\nrequires #rangeAddress(ACCT_ID)\nandBool #notPrecompileAddress(ACCT_ID)\nandBool #rangeAddress(CALLER_ID)\nandBool #rangeAddress(ORIGIN_ID)\nandBool #rangeUInt(256, TIME)\nandBool #rangeUInt(256, ACCT_ID_balance)\nandBool #rangeUInt(256, ECREC_BAL)\nandBool #rangeUInt(256, SHA256_BAL)\nandBool #rangeUInt(256, RIP160_BAL)\nandBool #rangeUInt(256, ID_BAL)\nandBool #rangeUInt(256, MODEXP_BAL)\nandBool #rangeUInt(256, ECADD_BAL)\nandBool #rangeUInt(256, ECMUL_BAL)\nandBool #rangeUInt(256, ECPAIRING_BAL)\nandBool VCallDepth <=Int 1024\nandBool #rangeUInt(256, VCallValue)\n\n  andBool (#rangeAddress(ABI__to)\n  andBool (#rangeUInt(256, ABI__value)\n  andBool (#rangeUInt(256, FromBal)\n  andBool (#rangeUInt(256, ToBal)\n  andBool ((#sizeWordStack(CD) <=Int 1250000000)\n  andBool ((FromBal >=Int ABI__value)\n  andBool ((ABI__value >Int 0)\n  andBool ((CALLER_ID =/=Int ABI__to)\n  andBool (VGas >=Int 3000000\n  andBool (((#rangeUInt(256, FromBal -Int ABI__value)))\n  andBool (((#rangeUInt(256, ToBal +Int ABI__value)))\n  andBool ((VCallValue ==Int 0))))))))))))) \n\nendmodule\n","hash":"82a642201ad8fb6a586c9475410ca211fb44d3a8189d3ae4116d6147090e403d","status":"accept"},{"act":{"isStatic":false,"name":"transfer","subject":"StandardToken","varname2alias":{"ACCT_ID":"StandardToken"},"act_name":"StandardToken_transfer.act","internal":false,"sig":"transfer(address,uint256)","callData":"#abiCallData(\"transfer\", #address(ABI__to), #uint256(ABI__value)) ++ CD","signature":"transfer(address,uint256)","types":{"ABI__to":"address","ABI__value":"uint256","FromBal":"uint256","ToBal":"uint256"},"if":["(#sizeWordStack(CD) <=Int 1250000000)","(FromBal >=Int ABI__value)","(ABI__value >Int 0)","(CALLER_ID =/=Int ABI__to)"],"interface":[["address","_to"],["uint256","_value"]],"fname":"transfer","storage":{"ACCT_ID":{"balances[CALLER_ID]":["FromBal","FromBal - _value"],"balances[_to]":["ToBal  ","ToBal + _value"]}},"iff":["((#rangeUInt(256, FromBal -Int ABI__value)))","((#rangeUInt(256, ToBal +Int ABI__value)))","(VCallValue ==Int 0)"],"iff_orig":["VCallValue == 0"],"if_orig":["FromBal >= _value","_value > 0","CALLER_ID =/= _to"],"returns":["1"],"ensures":["FAILURE =/=K EVMC_SUCCESS"]},"pass":false,"splitNumber":-1,"gas":3000000,"oog":false,"name":"StandardToken_transfer_fail_rough","spec":"// StandardToken_transfer\nrule [StandardToken.transfer.fail.rough]:\n  <k> #execute ~> CONTINUATION => #halt ~> CONTINUATION </k>\n  <exit-code> 1 </exit-code>\n  <mode> NORMAL </mode>\n  <schedule> PETERSBURG </schedule>\n  <ethereum>\n    <evm>\n      <output> _ => _ </output>\n      <statusCode> _ => FAILURE:EndStatusCode </statusCode>\n      <callStack> VCallStack </callStack>\n      <interimStates> _ </interimStates>\n      <touchedAccounts> _ => _ </touchedAccounts>\n      <callState>\n        <program> #asMapOpCodes(#dasmOpCodes(StandardToken_bin_runtime, PETERSBURG)) </program>\n        <programBytes> StandardToken_bin_runtime </programBytes>\n        <id> ACCT_ID </id>\n        <caller> CALLER_ID </caller>\n        <callData> #abiCallData(\"transfer\", #address(ABI__to), #uint256(ABI__value)) ++ CD => _ </callData>\n        <callValue> VCallValue </callValue>\n        <wordStack> .WordStack => _ </wordStack>\n        <localMem> .Map => _ </localMem>\n        <pc> 0 => _ </pc>\n        <gas> VGas => _ </gas>\n        <memoryUsed> 0 => _ </memoryUsed>\n        <callGas> _ => _ </callGas>\n        <static> false </static>\n        <callDepth> VCallDepth => _ </callDepth>\n      </callState>\n      <substate>\n        <selfDestruct> VSelfDestruct </selfDestruct>\n        <log> _ => VLog </log>\n        <refund> _ => VRefund </refund>\n      </substate>\n      <gasPrice> _ </gasPrice>\n      <origin> ORIGIN_ID </origin>\n      <previousHash> _ </previousHash>\n      <ommersHash> _ </ommersHash>\n      <coinbase> _ </coinbase>\n      <stateRoot> _ </stateRoot>\n      <transactionsRoot> _ </transactionsRoot>\n      <receiptsRoot> _ </receiptsRoot>\n      <logsBloom> _ </logsBloom>\n      <difficulty> _ </difficulty>\n      <number> _ </number>\n      <gasLimit> _ </gasLimit>\n      <gasUsed> _ </gasUsed>\n      <timestamp> TIME </timestamp>\n      <extraData> _ </extraData>\n      <mixHash> _ </mixHash>\n      <blockNonce> _ </blockNonce>\n      <ommerBlockHeaders> _ </ommerBlockHeaders>\n      <blockhash> _ </blockhash>\n    </evm>\n    <network>\n      <activeAccounts> SetItem(ACCT_ID)\n      SetItem(1)\n      SetItem(2)\n      SetItem(3)\n      SetItem(4)\n      SetItem(5)\n      SetItem(6)\n      SetItem(7)\n      SetItem(8) _ </activeAccounts>\n      <accounts>\n        <account>\n          <acctID> ACCT_ID </acctID>\n          <balance> ACCT_ID_balance </balance>\n          <code> StandardToken_bin_runtime </code>\n          <storage>         \n           .Map \n          [#StandardToken.balances[CALLER_ID] <- (FromBal => _)]        \n          [#StandardToken.balances[ABI__to] <- (ToBal   => _)]\n            _:Map \n           </storage>\n          <origStorage> _ </origStorage>\n          <nonce> _ </nonce>\n        </account>\n        <account>\n          <acctID> 1 </acctID>\n          <balance> ECREC_BAL </balance>\n          <code> .WordStack </code>\n          <storage> _:Map </storage>\n          <origStorage> _ </origStorage>\n          <nonce> _ </nonce>\n        </account>\n        <account>\n          <acctID> 2 </acctID>\n          <balance> SHA256_BAL </balance>\n          <code> .WordStack </code>\n          <storage> _:Map </storage>\n          <origStorage> _ </origStorage>\n          <nonce> _ </nonce>\n        </account>\n        <account>\n          <acctID> 3 </acctID>\n          <balance> RIP160_BAL </balance>\n          <code> .WordStack </code>\n          <storage> _:Map </storage>\n          <origStorage> _ </origStorage>\n          <nonce> _ </nonce>\n        </account>\n        <account>\n          <acctID> 4 </acctID>\n          <balance> ID_BAL </balance>\n          <code> .WordStack </code>\n          <storage> _:Map </storage>\n          <origStorage> _ </origStorage>\n          <nonce> _ </nonce>\n        </account>\n        <account>\n          <acctID> 5 </acctID>\n          <balance> MODEXP_BAL </balance>\n          <code> .WordStack </code>\n          <storage> _:Map </storage>\n          <origStorage> _ </origStorage>\n          <nonce> _ </nonce>\n        </account>\n        <account>\n          <acctID> 6 </acctID>\n          <balance> ECADD_BAL </balance>\n          <code> .WordStack </code>\n          <storage> _:Map </storage>\n          <origStorage> _ </origStorage>\n          <nonce> _ </nonce>\n        </account>\n        <account>\n          <acctID> 7 </acctID>\n          <balance> ECMUL_BAL </balance>\n          <code> .WordStack </code>\n          <storage> _:Map </storage>\n          <origStorage> _ </origStorage>\n          <nonce> _ </nonce>\n        </account>\n        <account>\n          <acctID> 8 </acctID>\n          <balance> ECPAIRING_BAL </balance>\n          <code> .WordStack </code>\n          <storage> _:Map </storage>\n          <origStorage> _ </origStorage>\n          <nonce> _ </nonce>\n        </account>\n       ... \n      </accounts>\n      <txOrder> _ </txOrder>\n      <txPending> _ </txPending>\n      <messages> _ </messages>\n    </network>\n  </ethereum>\nrequires #rangeAddress(ACCT_ID)\nandBool #notPrecompileAddress(ACCT_ID)\nandBool #rangeAddress(CALLER_ID)\nandBool #rangeAddress(ORIGIN_ID)\nandBool #rangeUInt(256, TIME)\nandBool #rangeUInt(256, ACCT_ID_balance)\nandBool #rangeUInt(256, ECREC_BAL)\nandBool #rangeUInt(256, SHA256_BAL)\nandBool #rangeUInt(256, RIP160_BAL)\nandBool #rangeUInt(256, ID_BAL)\nandBool #rangeUInt(256, MODEXP_BAL)\nandBool #rangeUInt(256, ECADD_BAL)\nandBool #rangeUInt(256, ECMUL_BAL)\nandBool #rangeUInt(256, ECPAIRING_BAL)\nandBool VCallDepth <=Int 1024\nandBool #rangeUInt(256, VCallValue)\n\n  andBool (#rangeAddress(ABI__to)\n  andBool (#rangeUInt(256, ABI__value)\n  andBool (#rangeUInt(256, FromBal)\n  andBool (#rangeUInt(256, ToBal)\n  andBool ((#sizeWordStack(CD) <=Int 1250000000)\n  andBool ((FromBal >=Int ABI__value)\n  andBool ((ABI__value >Int 0)\n  andBool ((CALLER_ID =/=Int ABI__to)\n  andBool (VGas >=Int 3000000)))))))))\n  andBool notBool (\n    (((#rangeUInt(256, FromBal:Int -Int ABI__value:Int)))\n    andBool (((#rangeUInt(256, ToBal:Int +Int ABI__value:Int)))\n    andBool ((VCallValue:Int ==Int 0))))\n  ) \nensures\nFAILURE =/=K EVMC_SUCCESS","v2n":{"ACCT_ID":"StandardToken"},"act_name":"StandardToken_transfer.act","imports":[],"closed":true,"ctx":[],"module":"requires \"../rules.k\"\nrequires \"../bin_runtime.k\"\n\nmodule B0EA0D261C8E49B07AD5F3C545DB1A1EB8ADC47BEB46715EE2820A3E444839C2\n  imports ETHEREUM-SIMULATION\n  imports EVM\n  imports RULES\n  imports BIN_RUNTIME\n\n// StandardToken_transfer\nrule [StandardToken.transfer.fail.rough]:\n  <k> #execute ~> CONTINUATION => #halt ~> CONTINUATION </k>\n  <exit-code> 1 </exit-code>\n  <mode> NORMAL </mode>\n  <schedule> PETERSBURG </schedule>\n  <ethereum>\n    <evm>\n      <output> _ => _ </output>\n      <statusCode> _ => FAILURE:EndStatusCode </statusCode>\n      <callStack> VCallStack </callStack>\n      <interimStates> _ </interimStates>\n      <touchedAccounts> _ => _ </touchedAccounts>\n      <callState>\n        <program> #asMapOpCodes(#dasmOpCodes(StandardToken_bin_runtime, PETERSBURG)) </program>\n        <programBytes> StandardToken_bin_runtime </programBytes>\n        <id> ACCT_ID </id>\n        <caller> CALLER_ID </caller>\n        <callData> #abiCallData(\"transfer\", #address(ABI__to), #uint256(ABI__value)) ++ CD => _ </callData>\n        <callValue> VCallValue </callValue>\n        <wordStack> .WordStack => _ </wordStack>\n        <localMem> .Map => _ </localMem>\n        <pc> 0 => _ </pc>\n        <gas> VGas => _ </gas>\n        <memoryUsed> 0 => _ </memoryUsed>\n        <callGas> _ => _ </callGas>\n        <static> false </static>\n        <callDepth> VCallDepth => _ </callDepth>\n      </callState>\n      <substate>\n        <selfDestruct> VSelfDestruct </selfDestruct>\n        <log> _ => VLog </log>\n        <refund> _ => VRefund </refund>\n      </substate>\n      <gasPrice> _ </gasPrice>\n      <origin> ORIGIN_ID </origin>\n      <previousHash> _ </previousHash>\n      <ommersHash> _ </ommersHash>\n      <coinbase> _ </coinbase>\n      <stateRoot> _ </stateRoot>\n      <transactionsRoot> _ </transactionsRoot>\n      <receiptsRoot> _ </receiptsRoot>\n      <logsBloom> _ </logsBloom>\n      <difficulty> _ </difficulty>\n      <number> _ </number>\n      <gasLimit> _ </gasLimit>\n      <gasUsed> _ </gasUsed>\n      <timestamp> TIME </timestamp>\n      <extraData> _ </extraData>\n      <mixHash> _ </mixHash>\n      <blockNonce> _ </blockNonce>\n      <ommerBlockHeaders> _ </ommerBlockHeaders>\n      <blockhash> _ </blockhash>\n    </evm>\n    <network>\n      <activeAccounts> SetItem(ACCT_ID)\n      SetItem(1)\n      SetItem(2)\n      SetItem(3)\n      SetItem(4)\n      SetItem(5)\n      SetItem(6)\n      SetItem(7)\n      SetItem(8) _ </activeAccounts>\n      <accounts>\n        <account>\n          <acctID> ACCT_ID </acctID>\n          <balance> ACCT_ID_balance </balance>\n          <code> StandardToken_bin_runtime </code>\n          <storage>         \n           .Map \n          [#StandardToken.balances[CALLER_ID] <- (FromBal => _)]        \n          [#StandardToken.balances[ABI__to] <- (ToBal   => _)]\n            _:Map \n           </storage>\n          <origStorage> _ </origStorage>\n          <nonce> _ </nonce>\n        </account>\n        <account>\n          <acctID> 1 </acctID>\n          <balance> ECREC_BAL </balance>\n          <code> .WordStack </code>\n          <storage> _:Map </storage>\n          <origStorage> _ </origStorage>\n          <nonce> _ </nonce>\n        </account>\n        <account>\n          <acctID> 2 </acctID>\n          <balance> SHA256_BAL </balance>\n          <code> .WordStack </code>\n          <storage> _:Map </storage>\n          <origStorage> _ </origStorage>\n          <nonce> _ </nonce>\n        </account>\n        <account>\n          <acctID> 3 </acctID>\n          <balance> RIP160_BAL </balance>\n          <code> .WordStack </code>\n          <storage> _:Map </storage>\n          <origStorage> _ </origStorage>\n          <nonce> _ </nonce>\n        </account>\n        <account>\n          <acctID> 4 </acctID>\n          <balance> ID_BAL </balance>\n          <code> .WordStack </code>\n          <storage> _:Map </storage>\n          <origStorage> _ </origStorage>\n          <nonce> _ </nonce>\n        </account>\n        <account>\n          <acctID> 5 </acctID>\n          <balance> MODEXP_BAL </balance>\n          <code> .WordStack </code>\n          <storage> _:Map </storage>\n          <origStorage> _ </origStorage>\n          <nonce> _ </nonce>\n        </account>\n        <account>\n          <acctID> 6 </acctID>\n          <balance> ECADD_BAL </balance>\n          <code> .WordStack </code>\n          <storage> _:Map </storage>\n          <origStorage> _ </origStorage>\n          <nonce> _ </nonce>\n        </account>\n        <account>\n          <acctID> 7 </acctID>\n          <balance> ECMUL_BAL </balance>\n          <code> .WordStack </code>\n          <storage> _:Map </storage>\n          <origStorage> _ </origStorage>\n          <nonce> _ </nonce>\n        </account>\n        <account>\n          <acctID> 8 </acctID>\n          <balance> ECPAIRING_BAL </balance>\n          <code> .WordStack </code>\n          <storage> _:Map </storage>\n          <origStorage> _ </origStorage>\n          <nonce> _ </nonce>\n        </account>\n       ... \n      </accounts>\n      <txOrder> _ </txOrder>\n      <txPending> _ </txPending>\n      <messages> _ </messages>\n    </network>\n  </ethereum>\nrequires #rangeAddress(ACCT_ID)\nandBool #notPrecompileAddress(ACCT_ID)\nandBool #rangeAddress(CALLER_ID)\nandBool #rangeAddress(ORIGIN_ID)\nandBool #rangeUInt(256, TIME)\nandBool #rangeUInt(256, ACCT_ID_balance)\nandBool #rangeUInt(256, ECREC_BAL)\nandBool #rangeUInt(256, SHA256_BAL)\nandBool #rangeUInt(256, RIP160_BAL)\nandBool #rangeUInt(256, ID_BAL)\nandBool #rangeUInt(256, MODEXP_BAL)\nandBool #rangeUInt(256, ECADD_BAL)\nandBool #rangeUInt(256, ECMUL_BAL)\nandBool #rangeUInt(256, ECPAIRING_BAL)\nandBool VCallDepth <=Int 1024\nandBool #rangeUInt(256, VCallValue)\n\n  andBool (#rangeAddress(ABI__to)\n  andBool (#rangeUInt(256, ABI__value)\n  andBool (#rangeUInt(256, FromBal)\n  andBool (#rangeUInt(256, ToBal)\n  andBool ((#sizeWordStack(CD) <=Int 1250000000)\n  andBool ((FromBal >=Int ABI__value)\n  andBool ((ABI__value >Int 0)\n  andBool ((CALLER_ID =/=Int ABI__to)\n  andBool (VGas >=Int 3000000)))))))))\n  andBool notBool (\n    (((#rangeUInt(256, FromBal:Int -Int ABI__value:Int)))\n    andBool (((#rangeUInt(256, ToBal:Int +Int ABI__value:Int)))\n    andBool ((VCallValue:Int ==Int 0))))\n  ) \nensures\nFAILURE =/=K EVMC_SUCCESS\n\nendmodule\n","hash":"b0ea0d261c8e49b07ad5f3c545db1a1eb8adc47beb46715ee2820a3e444839c2","status":"????"}],"text":"<div id=\"StandardToken_transfer(address,uint256)\"><div class=\"codeheader\">\n      <a class=\"anchor\" href=\"#StandardToken_transfer(address,uint256)\">⚓</a>\n      <a class=\"jumptop\" href=\"#top\">top</a>\n    </div><pre><code>behaviour transfer of StandardToken\ninterface transfer(address _to, uint256 _value)\n\ntypes\n  FromBal : uint256\n  ToBal   : uint256\n\nstorage\n  <span class=\"comment\">// </span>\n  balances[CALLER_ID] |-> FromBal => FromBal - _value\n  <span class=\"comment\">// </span>\n  balances[_to]       |-> ToBal   => ToBal + _value\n\niff in range uint256\n  FromBal - _value\n  ToBal + _value\n\niff\n  VCallValue == 0\n\nif\n  FromBal >= _value\n  _value > 0\n  CALLER_ID =/= _to\n\nreturns 1 </code></pre></div>"},{"type":"paragraph","text":"Transfer Fail"},{"type":"code","lang":"act","obj":{"isStatic":false,"name":"transfer_fail","subject":"StandardToken","varname2alias":{"ACCT_ID":"StandardToken"},"act_name":"StandardToken_transfer_fail.act","internal":false,"sig":"transfer(address,uint256)","callData":"#abiCallData(\"transfer\", #address(ABI__to), #uint256(ABI__value)) ++ CD","signature":"transfer(address,uint256)","types":{"ABI__to":"address","ABI__value":"uint256","FromBal":"uint256","ToBal":"uint256"},"if":["(#sizeWordStack(CD) <=Int 1250000000)","((FromBal <Int ABI__value orBool ABI__value ==Int 0))","(CALLER_ID =/=Int ABI__to)"],"interface":[["address","_to"],["uint256","_value"]],"fname":"transfer","storage":{"ACCT_ID":{"balances[CALLER_ID]":["FromBal","FromBal - _value"],"balances[_to]":["ToBal  ","ToBal + _value"]}},"iff":["((#rangeUInt(256, FromBal -Int ABI__value)))","((#rangeUInt(256, ToBal +Int ABI__value)))","(VCallValue ==Int 0)"],"iff_orig":["VCallValue == 0"],"if_orig":["(FromBal < _value or _value == 0)","CALLER_ID =/= _to"],"returns":["0"]},"cases":[{"act":{"isStatic":false,"name":"transfer_fail","subject":"StandardToken","varname2alias":{"ACCT_ID":"StandardToken"},"act_name":"StandardToken_transfer_fail.act","internal":false,"sig":"transfer(address,uint256)","callData":"#abiCallData(\"transfer\", #address(ABI__to), #uint256(ABI__value)) ++ CD","signature":"transfer(address,uint256)","types":{"ABI__to":"address","ABI__value":"uint256","FromBal":"uint256","ToBal":"uint256"},"if":["(#sizeWordStack(CD) <=Int 1250000000)","((FromBal <Int ABI__value orBool ABI__value ==Int 0))","(CALLER_ID =/=Int ABI__to)"],"interface":[["address","_to"],["uint256","_value"]],"fname":"transfer","storage":{"ACCT_ID":{"balances[CALLER_ID]":["FromBal","FromBal - _value"],"balances[_to]":["ToBal  ","ToBal + _value"]}},"iff":["((#rangeUInt(256, FromBal -Int ABI__value)))","((#rangeUInt(256, ToBal +Int ABI__value)))","(VCallValue ==Int 0)"],"iff_orig":["VCallValue == 0"],"if_orig":["(FromBal < _value or _value == 0)","CALLER_ID =/= _to"],"returns":["0"]},"name":"StandardToken_transfer_fail_pass_rough","pass":true,"rough":true,"oog":false,"splitNumber":-1,"gas":[3000000],"hasGas":false,"spec":"// StandardToken_transfer_fail\nrule [StandardToken.transfer.fail.pass.rough]:\n  <k> #execute ~> CONTINUATION => #halt ~> CONTINUATION </k>\n  <exit-code> 1 </exit-code>\n  <mode> NORMAL </mode>\n  <schedule> PETERSBURG </schedule>\n  <ethereum>\n    <evm>\n      <output> _ => #asByteStackInWidthaux(0, 31, 32, .WordStack) </output>\n      <statusCode> _ => EVMC_SUCCESS </statusCode>\n      <callStack> VCallStack </callStack>\n      <interimStates> _ </interimStates>\n      <touchedAccounts> _ => _ </touchedAccounts>\n      <callState>\n        <program> #asMapOpCodes(#dasmOpCodes(StandardToken_bin_runtime, PETERSBURG)) </program>\n        <programBytes> StandardToken_bin_runtime </programBytes>\n        <id> ACCT_ID </id>\n        <caller> CALLER_ID </caller>\n        <callData> #abiCallData(\"transfer\", #address(ABI__to), #uint256(ABI__value)) ++ CD => _ </callData>\n        <callValue> VCallValue </callValue>\n        <wordStack> .WordStack => _ </wordStack>\n        <localMem> .Map => _ </localMem>\n        <pc> 0 => _ </pc>\n        <gas> VGas => _ </gas>\n        <memoryUsed> 0 => _ </memoryUsed>\n        <callGas> _ => _ </callGas>\n        <static> false </static>\n        <callDepth> VCallDepth </callDepth>\n      </callState>\n      <substate>\n        <selfDestruct> VSelfDestruct </selfDestruct>\n        <log> _ => VLog </log>\n        <refund> _ => VRefund </refund>\n      </substate>\n      <gasPrice> _ </gasPrice>\n      <origin> ORIGIN_ID </origin>\n      <previousHash> _ </previousHash>\n      <ommersHash> _ </ommersHash>\n      <coinbase> _ </coinbase>\n      <stateRoot> _ </stateRoot>\n      <transactionsRoot> _ </transactionsRoot>\n      <receiptsRoot> _ </receiptsRoot>\n      <logsBloom> _ </logsBloom>\n      <difficulty> _ </difficulty>\n      <number> _ </number>\n      <gasLimit> _ </gasLimit>\n      <gasUsed> _ </gasUsed>\n      <timestamp> TIME </timestamp>\n      <extraData> _ </extraData>\n      <mixHash> _ </mixHash>\n      <blockNonce> _ </blockNonce>\n      <ommerBlockHeaders> _ </ommerBlockHeaders>\n      <blockhash> _ </blockhash>\n    </evm>\n    <network>\n      <activeAccounts> SetItem(ACCT_ID)\n      SetItem(1)\n      SetItem(2)\n      SetItem(3)\n      SetItem(4)\n      SetItem(5)\n      SetItem(6)\n      SetItem(7)\n      SetItem(8) _ </activeAccounts>\n      <accounts>\n        <account>\n          <acctID> ACCT_ID </acctID>\n          <balance> ACCT_ID_balance </balance>\n          <code> StandardToken_bin_runtime </code>\n          <storage>         \n           .Map \n          [#StandardToken.balances[CALLER_ID] <- (FromBal => FromBal -Int ABI__value)]        \n          [#StandardToken.balances[ABI__to] <- (ToBal   => ToBal +Int ABI__value)]\n            _:Map \n           </storage>\n          <origStorage> _ </origStorage>\n          <nonce> _ </nonce>\n        </account>\n        <account>\n          <acctID> 1 </acctID>\n          <balance> ECREC_BAL </balance>\n          <code> .WordStack </code>\n          <storage> _:Map </storage>\n          <origStorage> _ </origStorage>\n          <nonce> _ </nonce>\n        </account>\n        <account>\n          <acctID> 2 </acctID>\n          <balance> SHA256_BAL </balance>\n          <code> .WordStack </code>\n          <storage> _:Map </storage>\n          <origStorage> _ </origStorage>\n          <nonce> _ </nonce>\n        </account>\n        <account>\n          <acctID> 3 </acctID>\n          <balance> RIP160_BAL </balance>\n          <code> .WordStack </code>\n          <storage> _:Map </storage>\n          <origStorage> _ </origStorage>\n          <nonce> _ </nonce>\n        </account>\n        <account>\n          <acctID> 4 </acctID>\n          <balance> ID_BAL </balance>\n          <code> .WordStack </code>\n          <storage> _:Map </storage>\n          <origStorage> _ </origStorage>\n          <nonce> _ </nonce>\n        </account>\n        <account>\n          <acctID> 5 </acctID>\n          <balance> MODEXP_BAL </balance>\n          <code> .WordStack </code>\n          <storage> _:Map </storage>\n          <origStorage> _ </origStorage>\n          <nonce> _ </nonce>\n        </account>\n        <account>\n          <acctID> 6 </acctID>\n          <balance> ECADD_BAL </balance>\n          <code> .WordStack </code>\n          <storage> _:Map </storage>\n          <origStorage> _ </origStorage>\n          <nonce> _ </nonce>\n        </account>\n        <account>\n          <acctID> 7 </acctID>\n          <balance> ECMUL_BAL </balance>\n          <code> .WordStack </code>\n          <storage> _:Map </storage>\n          <origStorage> _ </origStorage>\n          <nonce> _ </nonce>\n        </account>\n        <account>\n          <acctID> 8 </acctID>\n          <balance> ECPAIRING_BAL </balance>\n          <code> .WordStack </code>\n          <storage> _:Map </storage>\n          <origStorage> _ </origStorage>\n          <nonce> _ </nonce>\n        </account>\n       ... \n      </accounts>\n      <txOrder> _ </txOrder>\n      <txPending> _ </txPending>\n      <messages> _ </messages>\n    </network>\n  </ethereum>\nrequires #rangeAddress(ACCT_ID)\nandBool #notPrecompileAddress(ACCT_ID)\nandBool #rangeAddress(CALLER_ID)\nandBool #rangeAddress(ORIGIN_ID)\nandBool #rangeUInt(256, TIME)\nandBool #rangeUInt(256, ACCT_ID_balance)\nandBool #rangeUInt(256, ECREC_BAL)\nandBool #rangeUInt(256, SHA256_BAL)\nandBool #rangeUInt(256, RIP160_BAL)\nandBool #rangeUInt(256, ID_BAL)\nandBool #rangeUInt(256, MODEXP_BAL)\nandBool #rangeUInt(256, ECADD_BAL)\nandBool #rangeUInt(256, ECMUL_BAL)\nandBool #rangeUInt(256, ECPAIRING_BAL)\nandBool VCallDepth <=Int 1024\nandBool #rangeUInt(256, VCallValue)\n\n  andBool (#rangeAddress(ABI__to)\n  andBool (#rangeUInt(256, ABI__value)\n  andBool (#rangeUInt(256, FromBal)\n  andBool (#rangeUInt(256, ToBal)\n  andBool ((#sizeWordStack(CD) <=Int 1250000000)\n  andBool (((FromBal <Int ABI__value orBool ABI__value ==Int 0))\n  andBool ((CALLER_ID =/=Int ABI__to)\n  andBool (VGas >=Int 3000000\n  andBool (((#rangeUInt(256, FromBal -Int ABI__value)))\n  andBool (((#rangeUInt(256, ToBal +Int ABI__value)))\n  andBool ((VCallValue ==Int 0)))))))))))) ","v2n":{"ACCT_ID":"StandardToken"},"act_name":"StandardToken_transfer_fail.act","imports":[],"closed":true,"ctx":[],"module":"requires \"../rules.k\"\nrequires \"../bin_runtime.k\"\n\nmodule 7D961069FDFC9AC025BF478398B9517B05E1C91894C0D6912EA7EF55EED7FFCD\n  imports ETHEREUM-SIMULATION\n  imports EVM\n  imports RULES\n  imports BIN_RUNTIME\n\n// StandardToken_transfer_fail\nrule [StandardToken.transfer.fail.pass.rough]:\n  <k> #execute ~> CONTINUATION => #halt ~> CONTINUATION </k>\n  <exit-code> 1 </exit-code>\n  <mode> NORMAL </mode>\n  <schedule> PETERSBURG </schedule>\n  <ethereum>\n    <evm>\n      <output> _ => #asByteStackInWidthaux(0, 31, 32, .WordStack) </output>\n      <statusCode> _ => EVMC_SUCCESS </statusCode>\n      <callStack> VCallStack </callStack>\n      <interimStates> _ </interimStates>\n      <touchedAccounts> _ => _ </touchedAccounts>\n      <callState>\n        <program> #asMapOpCodes(#dasmOpCodes(StandardToken_bin_runtime, PETERSBURG)) </program>\n        <programBytes> StandardToken_bin_runtime </programBytes>\n        <id> ACCT_ID </id>\n        <caller> CALLER_ID </caller>\n        <callData> #abiCallData(\"transfer\", #address(ABI__to), #uint256(ABI__value)) ++ CD => _ </callData>\n        <callValue> VCallValue </callValue>\n        <wordStack> .WordStack => _ </wordStack>\n        <localMem> .Map => _ </localMem>\n        <pc> 0 => _ </pc>\n        <gas> VGas => _ </gas>\n        <memoryUsed> 0 => _ </memoryUsed>\n        <callGas> _ => _ </callGas>\n        <static> false </static>\n        <callDepth> VCallDepth </callDepth>\n      </callState>\n      <substate>\n        <selfDestruct> VSelfDestruct </selfDestruct>\n        <log> _ => VLog </log>\n        <refund> _ => VRefund </refund>\n      </substate>\n      <gasPrice> _ </gasPrice>\n      <origin> ORIGIN_ID </origin>\n      <previousHash> _ </previousHash>\n      <ommersHash> _ </ommersHash>\n      <coinbase> _ </coinbase>\n      <stateRoot> _ </stateRoot>\n      <transactionsRoot> _ </transactionsRoot>\n      <receiptsRoot> _ </receiptsRoot>\n      <logsBloom> _ </logsBloom>\n      <difficulty> _ </difficulty>\n      <number> _ </number>\n      <gasLimit> _ </gasLimit>\n      <gasUsed> _ </gasUsed>\n      <timestamp> TIME </timestamp>\n      <extraData> _ </extraData>\n      <mixHash> _ </mixHash>\n      <blockNonce> _ </blockNonce>\n      <ommerBlockHeaders> _ </ommerBlockHeaders>\n      <blockhash> _ </blockhash>\n    </evm>\n    <network>\n      <activeAccounts> SetItem(ACCT_ID)\n      SetItem(1)\n      SetItem(2)\n      SetItem(3)\n      SetItem(4)\n      SetItem(5)\n      SetItem(6)\n      SetItem(7)\n      SetItem(8) _ </activeAccounts>\n      <accounts>\n        <account>\n          <acctID> ACCT_ID </acctID>\n          <balance> ACCT_ID_balance </balance>\n          <code> StandardToken_bin_runtime </code>\n          <storage>         \n           .Map \n          [#StandardToken.balances[CALLER_ID] <- (FromBal => FromBal -Int ABI__value)]        \n          [#StandardToken.balances[ABI__to] <- (ToBal   => ToBal +Int ABI__value)]\n            _:Map \n           </storage>\n          <origStorage> _ </origStorage>\n          <nonce> _ </nonce>\n        </account>\n        <account>\n          <acctID> 1 </acctID>\n          <balance> ECREC_BAL </balance>\n          <code> .WordStack </code>\n          <storage> _:Map </storage>\n          <origStorage> _ </origStorage>\n          <nonce> _ </nonce>\n        </account>\n        <account>\n          <acctID> 2 </acctID>\n          <balance> SHA256_BAL </balance>\n          <code> .WordStack </code>\n          <storage> _:Map </storage>\n          <origStorage> _ </origStorage>\n          <nonce> _ </nonce>\n        </account>\n        <account>\n          <acctID> 3 </acctID>\n          <balance> RIP160_BAL </balance>\n          <code> .WordStack </code>\n          <storage> _:Map </storage>\n          <origStorage> _ </origStorage>\n          <nonce> _ </nonce>\n        </account>\n        <account>\n          <acctID> 4 </acctID>\n          <balance> ID_BAL </balance>\n          <code> .WordStack </code>\n          <storage> _:Map </storage>\n          <origStorage> _ </origStorage>\n          <nonce> _ </nonce>\n        </account>\n        <account>\n          <acctID> 5 </acctID>\n          <balance> MODEXP_BAL </balance>\n          <code> .WordStack </code>\n          <storage> _:Map </storage>\n          <origStorage> _ </origStorage>\n          <nonce> _ </nonce>\n        </account>\n        <account>\n          <acctID> 6 </acctID>\n          <balance> ECADD_BAL </balance>\n          <code> .WordStack </code>\n          <storage> _:Map </storage>\n          <origStorage> _ </origStorage>\n          <nonce> _ </nonce>\n        </account>\n        <account>\n          <acctID> 7 </acctID>\n          <balance> ECMUL_BAL </balance>\n          <code> .WordStack </code>\n          <storage> _:Map </storage>\n          <origStorage> _ </origStorage>\n          <nonce> _ </nonce>\n        </account>\n        <account>\n          <acctID> 8 </acctID>\n          <balance> ECPAIRING_BAL </balance>\n          <code> .WordStack </code>\n          <storage> _:Map </storage>\n          <origStorage> _ </origStorage>\n          <nonce> _ </nonce>\n        </account>\n       ... \n      </accounts>\n      <txOrder> _ </txOrder>\n      <txPending> _ </txPending>\n      <messages> _ </messages>\n    </network>\n  </ethereum>\nrequires #rangeAddress(ACCT_ID)\nandBool #notPrecompileAddress(ACCT_ID)\nandBool #rangeAddress(CALLER_ID)\nandBool #rangeAddress(ORIGIN_ID)\nandBool #rangeUInt(256, TIME)\nandBool #rangeUInt(256, ACCT_ID_balance)\nandBool #rangeUInt(256, ECREC_BAL)\nandBool #rangeUInt(256, SHA256_BAL)\nandBool #rangeUInt(256, RIP160_BAL)\nandBool #rangeUInt(256, ID_BAL)\nandBool #rangeUInt(256, MODEXP_BAL)\nandBool #rangeUInt(256, ECADD_BAL)\nandBool #rangeUInt(256, ECMUL_BAL)\nandBool #rangeUInt(256, ECPAIRING_BAL)\nandBool VCallDepth <=Int 1024\nandBool #rangeUInt(256, VCallValue)\n\n  andBool (#rangeAddress(ABI__to)\n  andBool (#rangeUInt(256, ABI__value)\n  andBool (#rangeUInt(256, FromBal)\n  andBool (#rangeUInt(256, ToBal)\n  andBool ((#sizeWordStack(CD) <=Int 1250000000)\n  andBool (((FromBal <Int ABI__value orBool ABI__value ==Int 0))\n  andBool ((CALLER_ID =/=Int ABI__to)\n  andBool (VGas >=Int 3000000\n  andBool (((#rangeUInt(256, FromBal -Int ABI__value)))\n  andBool (((#rangeUInt(256, ToBal +Int ABI__value)))\n  andBool ((VCallValue ==Int 0)))))))))))) \n\nendmodule\n","hash":"7d961069fdfc9ac025bf478398b9517b05e1c91894c0d6912ea7ef55eed7ffcd","status":"accept"},{"act":{"isStatic":false,"name":"transfer_fail","subject":"StandardToken","varname2alias":{"ACCT_ID":"StandardToken"},"act_name":"StandardToken_transfer_fail.act","internal":false,"sig":"transfer(address,uint256)","callData":"#abiCallData(\"transfer\", #address(ABI__to), #uint256(ABI__value)) ++ CD","signature":"transfer(address,uint256)","types":{"ABI__to":"address","ABI__value":"uint256","FromBal":"uint256","ToBal":"uint256"},"if":["(#sizeWordStack(CD) <=Int 1250000000)","((FromBal <Int ABI__value orBool ABI__value ==Int 0))","(CALLER_ID =/=Int ABI__to)"],"interface":[["address","_to"],["uint256","_value"]],"fname":"transfer","storage":{"ACCT_ID":{"balances[CALLER_ID]":["FromBal","FromBal - _value"],"balances[_to]":["ToBal  ","ToBal + _value"]}},"iff":["((#rangeUInt(256, FromBal -Int ABI__value)))","((#rangeUInt(256, ToBal +Int ABI__value)))","(VCallValue ==Int 0)"],"iff_orig":["VCallValue == 0"],"if_orig":["(FromBal < _value or _value == 0)","CALLER_ID =/= _to"],"returns":["0"],"ensures":["FAILURE =/=K EVMC_SUCCESS"]},"pass":false,"splitNumber":-1,"gas":3000000,"oog":false,"name":"StandardToken_transfer_fail_fail_rough","spec":"// StandardToken_transfer_fail\nrule [StandardToken.transfer.fail.fail.rough]:\n  <k> #execute ~> CONTINUATION => #halt ~> CONTINUATION </k>\n  <exit-code> 1 </exit-code>\n  <mode> NORMAL </mode>\n  <schedule> PETERSBURG </schedule>\n  <ethereum>\n    <evm>\n      <output> _ => _ </output>\n      <statusCode> _ => FAILURE:EndStatusCode </statusCode>\n      <callStack> VCallStack </callStack>\n      <interimStates> _ </interimStates>\n      <touchedAccounts> _ => _ </touchedAccounts>\n      <callState>\n        <program> #asMapOpCodes(#dasmOpCodes(StandardToken_bin_runtime, PETERSBURG)) </program>\n        <programBytes> StandardToken_bin_runtime </programBytes>\n        <id> ACCT_ID </id>\n        <caller> CALLER_ID </caller>\n        <callData> #abiCallData(\"transfer\", #address(ABI__to), #uint256(ABI__value)) ++ CD => _ </callData>\n        <callValue> VCallValue </callValue>\n        <wordStack> .WordStack => _ </wordStack>\n        <localMem> .Map => _ </localMem>\n        <pc> 0 => _ </pc>\n        <gas> VGas => _ </gas>\n        <memoryUsed> 0 => _ </memoryUsed>\n        <callGas> _ => _ </callGas>\n        <static> false </static>\n        <callDepth> VCallDepth => _ </callDepth>\n      </callState>\n      <substate>\n        <selfDestruct> VSelfDestruct </selfDestruct>\n        <log> _ => VLog </log>\n        <refund> _ => VRefund </refund>\n      </substate>\n      <gasPrice> _ </gasPrice>\n      <origin> ORIGIN_ID </origin>\n      <previousHash> _ </previousHash>\n      <ommersHash> _ </ommersHash>\n      <coinbase> _ </coinbase>\n      <stateRoot> _ </stateRoot>\n      <transactionsRoot> _ </transactionsRoot>\n      <receiptsRoot> _ </receiptsRoot>\n      <logsBloom> _ </logsBloom>\n      <difficulty> _ </difficulty>\n      <number> _ </number>\n      <gasLimit> _ </gasLimit>\n      <gasUsed> _ </gasUsed>\n      <timestamp> TIME </timestamp>\n      <extraData> _ </extraData>\n      <mixHash> _ </mixHash>\n      <blockNonce> _ </blockNonce>\n      <ommerBlockHeaders> _ </ommerBlockHeaders>\n      <blockhash> _ </blockhash>\n    </evm>\n    <network>\n      <activeAccounts> SetItem(ACCT_ID)\n      SetItem(1)\n      SetItem(2)\n      SetItem(3)\n      SetItem(4)\n      SetItem(5)\n      SetItem(6)\n      SetItem(7)\n      SetItem(8) _ </activeAccounts>\n      <accounts>\n        <account>\n          <acctID> ACCT_ID </acctID>\n          <balance> ACCT_ID_balance </balance>\n          <code> StandardToken_bin_runtime </code>\n          <storage>         \n           .Map \n          [#StandardToken.balances[CALLER_ID] <- (FromBal => _)]        \n          [#StandardToken.balances[ABI__to] <- (ToBal   => _)]\n            _:Map \n           </storage>\n          <origStorage> _ </origStorage>\n          <nonce> _ </nonce>\n        </account>\n        <account>\n          <acctID> 1 </acctID>\n          <balance> ECREC_BAL </balance>\n          <code> .WordStack </code>\n          <storage> _:Map </storage>\n          <origStorage> _ </origStorage>\n          <nonce> _ </nonce>\n        </account>\n        <account>\n          <acctID> 2 </acctID>\n          <balance> SHA256_BAL </balance>\n          <code> .WordStack </code>\n          <storage> _:Map </storage>\n          <origStorage> _ </origStorage>\n          <nonce> _ </nonce>\n        </account>\n        <account>\n          <acctID> 3 </acctID>\n          <balance> RIP160_BAL </balance>\n          <code> .WordStack </code>\n          <storage> _:Map </storage>\n          <origStorage> _ </origStorage>\n          <nonce> _ </nonce>\n        </account>\n        <account>\n          <acctID> 4 </acctID>\n          <balance> ID_BAL </balance>\n          <code> .WordStack </code>\n          <storage> _:Map </storage>\n          <origStorage> _ </origStorage>\n          <nonce> _ </nonce>\n        </account>\n        <account>\n          <acctID> 5 </acctID>\n          <balance> MODEXP_BAL </balance>\n          <code> .WordStack </code>\n          <storage> _:Map </storage>\n          <origStorage> _ </origStorage>\n          <nonce> _ </nonce>\n        </account>\n        <account>\n          <acctID> 6 </acctID>\n          <balance> ECADD_BAL </balance>\n          <code> .WordStack </code>\n          <storage> _:Map </storage>\n          <origStorage> _ </origStorage>\n          <nonce> _ </nonce>\n        </account>\n        <account>\n          <acctID> 7 </acctID>\n          <balance> ECMUL_BAL </balance>\n          <code> .WordStack </code>\n          <storage> _:Map </storage>\n          <origStorage> _ </origStorage>\n          <nonce> _ </nonce>\n        </account>\n        <account>\n          <acctID> 8 </acctID>\n          <balance> ECPAIRING_BAL </balance>\n          <code> .WordStack </code>\n          <storage> _:Map </storage>\n          <origStorage> _ </origStorage>\n          <nonce> _ </nonce>\n        </account>\n       ... \n      </accounts>\n      <txOrder> _ </txOrder>\n      <txPending> _ </txPending>\n      <messages> _ </messages>\n    </network>\n  </ethereum>\nrequires #rangeAddress(ACCT_ID)\nandBool #notPrecompileAddress(ACCT_ID)\nandBool #rangeAddress(CALLER_ID)\nandBool #rangeAddress(ORIGIN_ID)\nandBool #rangeUInt(256, TIME)\nandBool #rangeUInt(256, ACCT_ID_balance)\nandBool #rangeUInt(256, ECREC_BAL)\nandBool #rangeUInt(256, SHA256_BAL)\nandBool #rangeUInt(256, RIP160_BAL)\nandBool #rangeUInt(256, ID_BAL)\nandBool #rangeUInt(256, MODEXP_BAL)\nandBool #rangeUInt(256, ECADD_BAL)\nandBool #rangeUInt(256, ECMUL_BAL)\nandBool #rangeUInt(256, ECPAIRING_BAL)\nandBool VCallDepth <=Int 1024\nandBool #rangeUInt(256, VCallValue)\n\n  andBool (#rangeAddress(ABI__to)\n  andBool (#rangeUInt(256, ABI__value)\n  andBool (#rangeUInt(256, FromBal)\n  andBool (#rangeUInt(256, ToBal)\n  andBool ((#sizeWordStack(CD) <=Int 1250000000)\n  andBool (((FromBal <Int ABI__value orBool ABI__value ==Int 0))\n  andBool ((CALLER_ID =/=Int ABI__to)\n  andBool (VGas >=Int 3000000))))))))\n  andBool notBool (\n    (((#rangeUInt(256, FromBal:Int -Int ABI__value:Int)))\n    andBool (((#rangeUInt(256, ToBal:Int +Int ABI__value:Int)))\n    andBool ((VCallValue:Int ==Int 0))))\n  ) \nensures\nFAILURE =/=K EVMC_SUCCESS","v2n":{"ACCT_ID":"StandardToken"},"act_name":"StandardToken_transfer_fail.act","imports":[],"closed":true,"ctx":[],"module":"requires \"../rules.k\"\nrequires \"../bin_runtime.k\"\n\nmodule 40C31226FEBADB92839EE26EC5562FC550B3775F7E181892EF18B6585BB25902\n  imports ETHEREUM-SIMULATION\n  imports EVM\n  imports RULES\n  imports BIN_RUNTIME\n\n// StandardToken_transfer_fail\nrule [StandardToken.transfer.fail.fail.rough]:\n  <k> #execute ~> CONTINUATION => #halt ~> CONTINUATION </k>\n  <exit-code> 1 </exit-code>\n  <mode> NORMAL </mode>\n  <schedule> PETERSBURG </schedule>\n  <ethereum>\n    <evm>\n      <output> _ => _ </output>\n      <statusCode> _ => FAILURE:EndStatusCode </statusCode>\n      <callStack> VCallStack </callStack>\n      <interimStates> _ </interimStates>\n      <touchedAccounts> _ => _ </touchedAccounts>\n      <callState>\n        <program> #asMapOpCodes(#dasmOpCodes(StandardToken_bin_runtime, PETERSBURG)) </program>\n        <programBytes> StandardToken_bin_runtime </programBytes>\n        <id> ACCT_ID </id>\n        <caller> CALLER_ID </caller>\n        <callData> #abiCallData(\"transfer\", #address(ABI__to), #uint256(ABI__value)) ++ CD => _ </callData>\n        <callValue> VCallValue </callValue>\n        <wordStack> .WordStack => _ </wordStack>\n        <localMem> .Map => _ </localMem>\n        <pc> 0 => _ </pc>\n        <gas> VGas => _ </gas>\n        <memoryUsed> 0 => _ </memoryUsed>\n        <callGas> _ => _ </callGas>\n        <static> false </static>\n        <callDepth> VCallDepth => _ </callDepth>\n      </callState>\n      <substate>\n        <selfDestruct> VSelfDestruct </selfDestruct>\n        <log> _ => VLog </log>\n        <refund> _ => VRefund </refund>\n      </substate>\n      <gasPrice> _ </gasPrice>\n      <origin> ORIGIN_ID </origin>\n      <previousHash> _ </previousHash>\n      <ommersHash> _ </ommersHash>\n      <coinbase> _ </coinbase>\n      <stateRoot> _ </stateRoot>\n      <transactionsRoot> _ </transactionsRoot>\n      <receiptsRoot> _ </receiptsRoot>\n      <logsBloom> _ </logsBloom>\n      <difficulty> _ </difficulty>\n      <number> _ </number>\n      <gasLimit> _ </gasLimit>\n      <gasUsed> _ </gasUsed>\n      <timestamp> TIME </timestamp>\n      <extraData> _ </extraData>\n      <mixHash> _ </mixHash>\n      <blockNonce> _ </blockNonce>\n      <ommerBlockHeaders> _ </ommerBlockHeaders>\n      <blockhash> _ </blockhash>\n    </evm>\n    <network>\n      <activeAccounts> SetItem(ACCT_ID)\n      SetItem(1)\n      SetItem(2)\n      SetItem(3)\n      SetItem(4)\n      SetItem(5)\n      SetItem(6)\n      SetItem(7)\n      SetItem(8) _ </activeAccounts>\n      <accounts>\n        <account>\n          <acctID> ACCT_ID </acctID>\n          <balance> ACCT_ID_balance </balance>\n          <code> StandardToken_bin_runtime </code>\n          <storage>         \n           .Map \n          [#StandardToken.balances[CALLER_ID] <- (FromBal => _)]        \n          [#StandardToken.balances[ABI__to] <- (ToBal   => _)]\n            _:Map \n           </storage>\n          <origStorage> _ </origStorage>\n          <nonce> _ </nonce>\n        </account>\n        <account>\n          <acctID> 1 </acctID>\n          <balance> ECREC_BAL </balance>\n          <code> .WordStack </code>\n          <storage> _:Map </storage>\n          <origStorage> _ </origStorage>\n          <nonce> _ </nonce>\n        </account>\n        <account>\n          <acctID> 2 </acctID>\n          <balance> SHA256_BAL </balance>\n          <code> .WordStack </code>\n          <storage> _:Map </storage>\n          <origStorage> _ </origStorage>\n          <nonce> _ </nonce>\n        </account>\n        <account>\n          <acctID> 3 </acctID>\n          <balance> RIP160_BAL </balance>\n          <code> .WordStack </code>\n          <storage> _:Map </storage>\n          <origStorage> _ </origStorage>\n          <nonce> _ </nonce>\n        </account>\n        <account>\n          <acctID> 4 </acctID>\n          <balance> ID_BAL </balance>\n          <code> .WordStack </code>\n          <storage> _:Map </storage>\n          <origStorage> _ </origStorage>\n          <nonce> _ </nonce>\n        </account>\n        <account>\n          <acctID> 5 </acctID>\n          <balance> MODEXP_BAL </balance>\n          <code> .WordStack </code>\n          <storage> _:Map </storage>\n          <origStorage> _ </origStorage>\n          <nonce> _ </nonce>\n        </account>\n        <account>\n          <acctID> 6 </acctID>\n          <balance> ECADD_BAL </balance>\n          <code> .WordStack </code>\n          <storage> _:Map </storage>\n          <origStorage> _ </origStorage>\n          <nonce> _ </nonce>\n        </account>\n        <account>\n          <acctID> 7 </acctID>\n          <balance> ECMUL_BAL </balance>\n          <code> .WordStack </code>\n          <storage> _:Map </storage>\n          <origStorage> _ </origStorage>\n          <nonce> _ </nonce>\n        </account>\n        <account>\n          <acctID> 8 </acctID>\n          <balance> ECPAIRING_BAL </balance>\n          <code> .WordStack </code>\n          <storage> _:Map </storage>\n          <origStorage> _ </origStorage>\n          <nonce> _ </nonce>\n        </account>\n       ... \n      </accounts>\n      <txOrder> _ </txOrder>\n      <txPending> _ </txPending>\n      <messages> _ </messages>\n    </network>\n  </ethereum>\nrequires #rangeAddress(ACCT_ID)\nandBool #notPrecompileAddress(ACCT_ID)\nandBool #rangeAddress(CALLER_ID)\nandBool #rangeAddress(ORIGIN_ID)\nandBool #rangeUInt(256, TIME)\nandBool #rangeUInt(256, ACCT_ID_balance)\nandBool #rangeUInt(256, ECREC_BAL)\nandBool #rangeUInt(256, SHA256_BAL)\nandBool #rangeUInt(256, RIP160_BAL)\nandBool #rangeUInt(256, ID_BAL)\nandBool #rangeUInt(256, MODEXP_BAL)\nandBool #rangeUInt(256, ECADD_BAL)\nandBool #rangeUInt(256, ECMUL_BAL)\nandBool #rangeUInt(256, ECPAIRING_BAL)\nandBool VCallDepth <=Int 1024\nandBool #rangeUInt(256, VCallValue)\n\n  andBool (#rangeAddress(ABI__to)\n  andBool (#rangeUInt(256, ABI__value)\n  andBool (#rangeUInt(256, FromBal)\n  andBool (#rangeUInt(256, ToBal)\n  andBool ((#sizeWordStack(CD) <=Int 1250000000)\n  andBool (((FromBal <Int ABI__value orBool ABI__value ==Int 0))\n  andBool ((CALLER_ID =/=Int ABI__to)\n  andBool (VGas >=Int 3000000))))))))\n  andBool notBool (\n    (((#rangeUInt(256, FromBal:Int -Int ABI__value:Int)))\n    andBool (((#rangeUInt(256, ToBal:Int +Int ABI__value:Int)))\n    andBool ((VCallValue:Int ==Int 0))))\n  ) \nensures\nFAILURE =/=K EVMC_SUCCESS\n\nendmodule\n","hash":"40c31226febadb92839ee26ec5562fc550b3775f7e181892ef18b6585bb25902","status":"????"}],"text":"<div id=\"StandardToken_transfer(address,uint256)\"><div class=\"codeheader\">\n      <a class=\"anchor\" href=\"#StandardToken_transfer(address,uint256)\">⚓</a>\n      <a class=\"jumptop\" href=\"#top\">top</a>\n    </div><pre><code>behaviour transfer_fail of StandardToken\ninterface transfer(address _to, uint256 _value)\n\ntypes\n  FromBal : uint256\n  ToBal   : uint256\n\nstorage\n  <span class=\"comment\">// </span>\n  balances[CALLER_ID] |-> FromBal => FromBal - _value\n  <span class=\"comment\">// </span>\n  balances[_to]       |-> ToBal   => ToBal + _value\n\niff in range uint256\n  FromBal - _value\n  ToBal + _value\n\niff\n  VCallValue == 0\n\nif\n  (FromBal < _value or _value == 0)\n  CALLER_ID =/= _to\n\nreturns 0</code></pre></div>"},{"type":"paragraph","text":"TransferFrom Pass"},{"type":"code","lang":"act","obj":{"isStatic":false,"name":"transferFrom","subject":"StandardToken","varname2alias":{"ACCT_ID":"StandardToken"},"act_name":"StandardToken_transferFrom.act","internal":false,"sig":"transferFrom(address,address,uint256)","callData":"#abiCallData(\"transferFrom\", #address(ABI_from), #address(ABI_to), #uint256(ABI_value)) ++ CD","signature":"transferFrom(address,address,uint256)","types":{"ABI_from":"address","ABI_to":"address","ABI_value":"uint256","Approval":"uint256","FromBal":"uint256","ToBal":"uint256"},"if":["(#sizeWordStack(CD) <=Int 1250000000)","(FromBal >=Int ABI_value)","(Approval >=Int ABI_value)","(ABI_value >Int 0)","(CALLER_ID =/=Int ABI_to)","(ABI_from =/=Int ABI_to)"],"interface":[["address","from"],["address","to"],["uint256","value"]],"fname":"transferFrom","storage":{"ACCT_ID":{"balances[from]":["FromBal ","FromBal - value"],"balances[to]":["ToBal   ","ToBal + value"],"approvals[from][CALLER_ID]":["Approval","Approval - value"]}},"iff":["((#rangeUInt(256, FromBal -Int ABI_value)))","((#rangeUInt(256, ToBal +Int ABI_value)))","((#rangeUInt(256, Approval -Int ABI_value)))","(VCallValue ==Int 0)"],"iff_orig":["VCallValue == 0"],"if_orig":["FromBal >= value","Approval >= value","value > 0","CALLER_ID =/= to","from =/= to"],"returns":["1"]},"cases":[{"act":{"isStatic":false,"name":"transferFrom","subject":"StandardToken","varname2alias":{"ACCT_ID":"StandardToken"},"act_name":"StandardToken_transferFrom.act","internal":false,"sig":"transferFrom(address,address,uint256)","callData":"#abiCallData(\"transferFrom\", #address(ABI_from), #address(ABI_to), #uint256(ABI_value)) ++ CD","signature":"transferFrom(address,address,uint256)","types":{"ABI_from":"address","ABI_to":"address","ABI_value":"uint256","Approval":"uint256","FromBal":"uint256","ToBal":"uint256"},"if":["(#sizeWordStack(CD) <=Int 1250000000)","(FromBal >=Int ABI_value)","(Approval >=Int ABI_value)","(ABI_value >Int 0)","(CALLER_ID =/=Int ABI_to)","(ABI_from =/=Int ABI_to)"],"interface":[["address","from"],["address","to"],["uint256","value"]],"fname":"transferFrom","storage":{"ACCT_ID":{"balances[from]":["FromBal ","FromBal - value"],"balances[to]":["ToBal   ","ToBal + value"],"approvals[from][CALLER_ID]":["Approval","Approval - value"]}},"iff":["((#rangeUInt(256, FromBal -Int ABI_value)))","((#rangeUInt(256, ToBal +Int ABI_value)))","((#rangeUInt(256, Approval -Int ABI_value)))","(VCallValue ==Int 0)"],"iff_orig":["VCallValue == 0"],"if_orig":["FromBal >= value","Approval >= value","value > 0","CALLER_ID =/= to","from =/= to"],"returns":["1"]},"name":"StandardToken_transferFrom_pass_rough","pass":true,"rough":true,"oog":false,"splitNumber":-1,"gas":[3000000],"hasGas":false,"spec":"// StandardToken_transferFrom\nrule [StandardToken.transferFrom.pass.rough]:\n  <k> #execute ~> CONTINUATION => #halt ~> CONTINUATION </k>\n  <exit-code> 1 </exit-code>\n  <mode> NORMAL </mode>\n  <schedule> PETERSBURG </schedule>\n  <ethereum>\n    <evm>\n      <output> _ => #asByteStackInWidthaux(1, 31, 32, .WordStack) </output>\n      <statusCode> _ => EVMC_SUCCESS </statusCode>\n      <callStack> VCallStack </callStack>\n      <interimStates> _ </interimStates>\n      <touchedAccounts> _ => _ </touchedAccounts>\n      <callState>\n        <program> #asMapOpCodes(#dasmOpCodes(StandardToken_bin_runtime, PETERSBURG)) </program>\n        <programBytes> StandardToken_bin_runtime </programBytes>\n        <id> ACCT_ID </id>\n        <caller> CALLER_ID </caller>\n        <callData> #abiCallData(\"transferFrom\", #address(ABI_from), #address(ABI_to), #uint256(ABI_value)) ++ CD => _ </callData>\n        <callValue> VCallValue </callValue>\n        <wordStack> .WordStack => _ </wordStack>\n        <localMem> .Map => _ </localMem>\n        <pc> 0 => _ </pc>\n        <gas> VGas => _ </gas>\n        <memoryUsed> 0 => _ </memoryUsed>\n        <callGas> _ => _ </callGas>\n        <static> false </static>\n        <callDepth> VCallDepth </callDepth>\n      </callState>\n      <substate>\n        <selfDestruct> VSelfDestruct </selfDestruct>\n        <log> _ => VLog </log>\n        <refund> _ => VRefund </refund>\n      </substate>\n      <gasPrice> _ </gasPrice>\n      <origin> ORIGIN_ID </origin>\n      <previousHash> _ </previousHash>\n      <ommersHash> _ </ommersHash>\n      <coinbase> _ </coinbase>\n      <stateRoot> _ </stateRoot>\n      <transactionsRoot> _ </transactionsRoot>\n      <receiptsRoot> _ </receiptsRoot>\n      <logsBloom> _ </logsBloom>\n      <difficulty> _ </difficulty>\n      <number> _ </number>\n      <gasLimit> _ </gasLimit>\n      <gasUsed> _ </gasUsed>\n      <timestamp> TIME </timestamp>\n      <extraData> _ </extraData>\n      <mixHash> _ </mixHash>\n      <blockNonce> _ </blockNonce>\n      <ommerBlockHeaders> _ </ommerBlockHeaders>\n      <blockhash> _ </blockhash>\n    </evm>\n    <network>\n      <activeAccounts> SetItem(ACCT_ID)\n      SetItem(1)\n      SetItem(2)\n      SetItem(3)\n      SetItem(4)\n      SetItem(5)\n      SetItem(6)\n      SetItem(7)\n      SetItem(8) _ </activeAccounts>\n      <accounts>\n        <account>\n          <acctID> ACCT_ID </acctID>\n          <balance> ACCT_ID_balance </balance>\n          <code> StandardToken_bin_runtime </code>\n          <storage>         \n           .Map \n          [#StandardToken.balances[ABI_from] <- (FromBal  => FromBal -Int ABI_value)]        \n          [#StandardToken.balances[ABI_to] <- (ToBal    => ToBal +Int ABI_value)]        \n          [#StandardToken.approvals[ABI_from][CALLER_ID] <- (Approval => Approval -Int ABI_value)]\n            _:Map \n           </storage>\n          <origStorage> _ </origStorage>\n          <nonce> _ </nonce>\n        </account>\n        <account>\n          <acctID> 1 </acctID>\n          <balance> ECREC_BAL </balance>\n          <code> .WordStack </code>\n          <storage> _:Map </storage>\n          <origStorage> _ </origStorage>\n          <nonce> _ </nonce>\n        </account>\n        <account>\n          <acctID> 2 </acctID>\n          <balance> SHA256_BAL </balance>\n          <code> .WordStack </code>\n          <storage> _:Map </storage>\n          <origStorage> _ </origStorage>\n          <nonce> _ </nonce>\n        </account>\n        <account>\n          <acctID> 3 </acctID>\n          <balance> RIP160_BAL </balance>\n          <code> .WordStack </code>\n          <storage> _:Map </storage>\n          <origStorage> _ </origStorage>\n          <nonce> _ </nonce>\n        </account>\n        <account>\n          <acctID> 4 </acctID>\n          <balance> ID_BAL </balance>\n          <code> .WordStack </code>\n          <storage> _:Map </storage>\n          <origStorage> _ </origStorage>\n          <nonce> _ </nonce>\n        </account>\n        <account>\n          <acctID> 5 </acctID>\n          <balance> MODEXP_BAL </balance>\n          <code> .WordStack </code>\n          <storage> _:Map </storage>\n          <origStorage> _ </origStorage>\n          <nonce> _ </nonce>\n        </account>\n        <account>\n          <acctID> 6 </acctID>\n          <balance> ECADD_BAL </balance>\n          <code> .WordStack </code>\n          <storage> _:Map </storage>\n          <origStorage> _ </origStorage>\n          <nonce> _ </nonce>\n        </account>\n        <account>\n          <acctID> 7 </acctID>\n          <balance> ECMUL_BAL </balance>\n          <code> .WordStack </code>\n          <storage> _:Map </storage>\n          <origStorage> _ </origStorage>\n          <nonce> _ </nonce>\n        </account>\n        <account>\n          <acctID> 8 </acctID>\n          <balance> ECPAIRING_BAL </balance>\n          <code> .WordStack </code>\n          <storage> _:Map </storage>\n          <origStorage> _ </origStorage>\n          <nonce> _ </nonce>\n        </account>\n       ... \n      </accounts>\n      <txOrder> _ </txOrder>\n      <txPending> _ </txPending>\n      <messages> _ </messages>\n    </network>\n  </ethereum>\nrequires #rangeAddress(ACCT_ID)\nandBool #notPrecompileAddress(ACCT_ID)\nandBool #rangeAddress(CALLER_ID)\nandBool #rangeAddress(ORIGIN_ID)\nandBool #rangeUInt(256, TIME)\nandBool #rangeUInt(256, ACCT_ID_balance)\nandBool #rangeUInt(256, ECREC_BAL)\nandBool #rangeUInt(256, SHA256_BAL)\nandBool #rangeUInt(256, RIP160_BAL)\nandBool #rangeUInt(256, ID_BAL)\nandBool #rangeUInt(256, MODEXP_BAL)\nandBool #rangeUInt(256, ECADD_BAL)\nandBool #rangeUInt(256, ECMUL_BAL)\nandBool #rangeUInt(256, ECPAIRING_BAL)\nandBool VCallDepth <=Int 1024\nandBool #rangeUInt(256, VCallValue)\n\n  andBool (#rangeAddress(ABI_from)\n  andBool (#rangeAddress(ABI_to)\n  andBool (#rangeUInt(256, ABI_value)\n  andBool (#rangeUInt(256, Approval)\n  andBool (#rangeUInt(256, FromBal)\n  andBool (#rangeUInt(256, ToBal)\n  andBool ((#sizeWordStack(CD) <=Int 1250000000)\n  andBool ((FromBal >=Int ABI_value)\n  andBool ((Approval >=Int ABI_value)\n  andBool ((ABI_value >Int 0)\n  andBool ((CALLER_ID =/=Int ABI_to)\n  andBool ((ABI_from =/=Int ABI_to)\n  andBool (VGas >=Int 3000000\n  andBool (((#rangeUInt(256, FromBal -Int ABI_value)))\n  andBool (((#rangeUInt(256, ToBal +Int ABI_value)))\n  andBool (((#rangeUInt(256, Approval -Int ABI_value)))\n  andBool ((VCallValue ==Int 0)))))))))))))))))) ","v2n":{"ACCT_ID":"StandardToken"},"act_name":"StandardToken_transferFrom.act","imports":[],"closed":true,"ctx":[],"module":"requires \"../rules.k\"\nrequires \"../bin_runtime.k\"\n\nmodule F707A47F3F97A77952128E8FF7D60CE5E435E09D4A0E1E6D246EC9386A71BDF7\n  imports ETHEREUM-SIMULATION\n  imports EVM\n  imports RULES\n  imports BIN_RUNTIME\n\n// StandardToken_transferFrom\nrule [StandardToken.transferFrom.pass.rough]:\n  <k> #execute ~> CONTINUATION => #halt ~> CONTINUATION </k>\n  <exit-code> 1 </exit-code>\n  <mode> NORMAL </mode>\n  <schedule> PETERSBURG </schedule>\n  <ethereum>\n    <evm>\n      <output> _ => #asByteStackInWidthaux(1, 31, 32, .WordStack) </output>\n      <statusCode> _ => EVMC_SUCCESS </statusCode>\n      <callStack> VCallStack </callStack>\n      <interimStates> _ </interimStates>\n      <touchedAccounts> _ => _ </touchedAccounts>\n      <callState>\n        <program> #asMapOpCodes(#dasmOpCodes(StandardToken_bin_runtime, PETERSBURG)) </program>\n        <programBytes> StandardToken_bin_runtime </programBytes>\n        <id> ACCT_ID </id>\n        <caller> CALLER_ID </caller>\n        <callData> #abiCallData(\"transferFrom\", #address(ABI_from), #address(ABI_to), #uint256(ABI_value)) ++ CD => _ </callData>\n        <callValue> VCallValue </callValue>\n        <wordStack> .WordStack => _ </wordStack>\n        <localMem> .Map => _ </localMem>\n        <pc> 0 => _ </pc>\n        <gas> VGas => _ </gas>\n        <memoryUsed> 0 => _ </memoryUsed>\n        <callGas> _ => _ </callGas>\n        <static> false </static>\n        <callDepth> VCallDepth </callDepth>\n      </callState>\n      <substate>\n        <selfDestruct> VSelfDestruct </selfDestruct>\n        <log> _ => VLog </log>\n        <refund> _ => VRefund </refund>\n      </substate>\n      <gasPrice> _ </gasPrice>\n      <origin> ORIGIN_ID </origin>\n      <previousHash> _ </previousHash>\n      <ommersHash> _ </ommersHash>\n      <coinbase> _ </coinbase>\n      <stateRoot> _ </stateRoot>\n      <transactionsRoot> _ </transactionsRoot>\n      <receiptsRoot> _ </receiptsRoot>\n      <logsBloom> _ </logsBloom>\n      <difficulty> _ </difficulty>\n      <number> _ </number>\n      <gasLimit> _ </gasLimit>\n      <gasUsed> _ </gasUsed>\n      <timestamp> TIME </timestamp>\n      <extraData> _ </extraData>\n      <mixHash> _ </mixHash>\n      <blockNonce> _ </blockNonce>\n      <ommerBlockHeaders> _ </ommerBlockHeaders>\n      <blockhash> _ </blockhash>\n    </evm>\n    <network>\n      <activeAccounts> SetItem(ACCT_ID)\n      SetItem(1)\n      SetItem(2)\n      SetItem(3)\n      SetItem(4)\n      SetItem(5)\n      SetItem(6)\n      SetItem(7)\n      SetItem(8) _ </activeAccounts>\n      <accounts>\n        <account>\n          <acctID> ACCT_ID </acctID>\n          <balance> ACCT_ID_balance </balance>\n          <code> StandardToken_bin_runtime </code>\n          <storage>         \n           .Map \n          [#StandardToken.balances[ABI_from] <- (FromBal  => FromBal -Int ABI_value)]        \n          [#StandardToken.balances[ABI_to] <- (ToBal    => ToBal +Int ABI_value)]        \n          [#StandardToken.approvals[ABI_from][CALLER_ID] <- (Approval => Approval -Int ABI_value)]\n            _:Map \n           </storage>\n          <origStorage> _ </origStorage>\n          <nonce> _ </nonce>\n        </account>\n        <account>\n          <acctID> 1 </acctID>\n          <balance> ECREC_BAL </balance>\n          <code> .WordStack </code>\n          <storage> _:Map </storage>\n          <origStorage> _ </origStorage>\n          <nonce> _ </nonce>\n        </account>\n        <account>\n          <acctID> 2 </acctID>\n          <balance> SHA256_BAL </balance>\n          <code> .WordStack </code>\n          <storage> _:Map </storage>\n          <origStorage> _ </origStorage>\n          <nonce> _ </nonce>\n        </account>\n        <account>\n          <acctID> 3 </acctID>\n          <balance> RIP160_BAL </balance>\n          <code> .WordStack </code>\n          <storage> _:Map </storage>\n          <origStorage> _ </origStorage>\n          <nonce> _ </nonce>\n        </account>\n        <account>\n          <acctID> 4 </acctID>\n          <balance> ID_BAL </balance>\n          <code> .WordStack </code>\n          <storage> _:Map </storage>\n          <origStorage> _ </origStorage>\n          <nonce> _ </nonce>\n        </account>\n        <account>\n          <acctID> 5 </acctID>\n          <balance> MODEXP_BAL </balance>\n          <code> .WordStack </code>\n          <storage> _:Map </storage>\n          <origStorage> _ </origStorage>\n          <nonce> _ </nonce>\n        </account>\n        <account>\n          <acctID> 6 </acctID>\n          <balance> ECADD_BAL </balance>\n          <code> .WordStack </code>\n          <storage> _:Map </storage>\n          <origStorage> _ </origStorage>\n          <nonce> _ </nonce>\n        </account>\n        <account>\n          <acctID> 7 </acctID>\n          <balance> ECMUL_BAL </balance>\n          <code> .WordStack </code>\n          <storage> _:Map </storage>\n          <origStorage> _ </origStorage>\n          <nonce> _ </nonce>\n        </account>\n        <account>\n          <acctID> 8 </acctID>\n          <balance> ECPAIRING_BAL </balance>\n          <code> .WordStack </code>\n          <storage> _:Map </storage>\n          <origStorage> _ </origStorage>\n          <nonce> _ </nonce>\n        </account>\n       ... \n      </accounts>\n      <txOrder> _ </txOrder>\n      <txPending> _ </txPending>\n      <messages> _ </messages>\n    </network>\n  </ethereum>\nrequires #rangeAddress(ACCT_ID)\nandBool #notPrecompileAddress(ACCT_ID)\nandBool #rangeAddress(CALLER_ID)\nandBool #rangeAddress(ORIGIN_ID)\nandBool #rangeUInt(256, TIME)\nandBool #rangeUInt(256, ACCT_ID_balance)\nandBool #rangeUInt(256, ECREC_BAL)\nandBool #rangeUInt(256, SHA256_BAL)\nandBool #rangeUInt(256, RIP160_BAL)\nandBool #rangeUInt(256, ID_BAL)\nandBool #rangeUInt(256, MODEXP_BAL)\nandBool #rangeUInt(256, ECADD_BAL)\nandBool #rangeUInt(256, ECMUL_BAL)\nandBool #rangeUInt(256, ECPAIRING_BAL)\nandBool VCallDepth <=Int 1024\nandBool #rangeUInt(256, VCallValue)\n\n  andBool (#rangeAddress(ABI_from)\n  andBool (#rangeAddress(ABI_to)\n  andBool (#rangeUInt(256, ABI_value)\n  andBool (#rangeUInt(256, Approval)\n  andBool (#rangeUInt(256, FromBal)\n  andBool (#rangeUInt(256, ToBal)\n  andBool ((#sizeWordStack(CD) <=Int 1250000000)\n  andBool ((FromBal >=Int ABI_value)\n  andBool ((Approval >=Int ABI_value)\n  andBool ((ABI_value >Int 0)\n  andBool ((CALLER_ID =/=Int ABI_to)\n  andBool ((ABI_from =/=Int ABI_to)\n  andBool (VGas >=Int 3000000\n  andBool (((#rangeUInt(256, FromBal -Int ABI_value)))\n  andBool (((#rangeUInt(256, ToBal +Int ABI_value)))\n  andBool (((#rangeUInt(256, Approval -Int ABI_value)))\n  andBool ((VCallValue ==Int 0)))))))))))))))))) \n\nendmodule\n","hash":"f707a47f3f97a77952128e8ff7d60ce5e435e09d4a0e1e6d246ec9386a71bdf7","status":"accept"},{"act":{"isStatic":false,"name":"transferFrom","subject":"StandardToken","varname2alias":{"ACCT_ID":"StandardToken"},"act_name":"StandardToken_transferFrom.act","internal":false,"sig":"transferFrom(address,address,uint256)","callData":"#abiCallData(\"transferFrom\", #address(ABI_from), #address(ABI_to), #uint256(ABI_value)) ++ CD","signature":"transferFrom(address,address,uint256)","types":{"ABI_from":"address","ABI_to":"address","ABI_value":"uint256","Approval":"uint256","FromBal":"uint256","ToBal":"uint256"},"if":["(#sizeWordStack(CD) <=Int 1250000000)","(FromBal >=Int ABI_value)","(Approval >=Int ABI_value)","(ABI_value >Int 0)","(CALLER_ID =/=Int ABI_to)","(ABI_from =/=Int ABI_to)"],"interface":[["address","from"],["address","to"],["uint256","value"]],"fname":"transferFrom","storage":{"ACCT_ID":{"balances[from]":["FromBal ","FromBal - value"],"balances[to]":["ToBal   ","ToBal + value"],"approvals[from][CALLER_ID]":["Approval","Approval - value"]}},"iff":["((#rangeUInt(256, FromBal -Int ABI_value)))","((#rangeUInt(256, ToBal +Int ABI_value)))","((#rangeUInt(256, Approval -Int ABI_value)))","(VCallValue ==Int 0)"],"iff_orig":["VCallValue == 0"],"if_orig":["FromBal >= value","Approval >= value","value > 0","CALLER_ID =/= to","from =/= to"],"returns":["1"],"ensures":["FAILURE =/=K EVMC_SUCCESS"]},"pass":false,"splitNumber":-1,"gas":3000000,"oog":false,"name":"StandardToken_transferFrom_fail_rough","spec":"// StandardToken_transferFrom\nrule [StandardToken.transferFrom.fail.rough]:\n  <k> #execute ~> CONTINUATION => #halt ~> CONTINUATION </k>\n  <exit-code> 1 </exit-code>\n  <mode> NORMAL </mode>\n  <schedule> PETERSBURG </schedule>\n  <ethereum>\n    <evm>\n      <output> _ => _ </output>\n      <statusCode> _ => FAILURE:EndStatusCode </statusCode>\n      <callStack> VCallStack </callStack>\n      <interimStates> _ </interimStates>\n      <touchedAccounts> _ => _ </touchedAccounts>\n      <callState>\n        <program> #asMapOpCodes(#dasmOpCodes(StandardToken_bin_runtime, PETERSBURG)) </program>\n        <programBytes> StandardToken_bin_runtime </programBytes>\n        <id> ACCT_ID </id>\n        <caller> CALLER_ID </caller>\n        <callData> #abiCallData(\"transferFrom\", #address(ABI_from), #address(ABI_to), #uint256(ABI_value)) ++ CD => _ </callData>\n        <callValue> VCallValue </callValue>\n        <wordStack> .WordStack => _ </wordStack>\n        <localMem> .Map => _ </localMem>\n        <pc> 0 => _ </pc>\n        <gas> VGas => _ </gas>\n        <memoryUsed> 0 => _ </memoryUsed>\n        <callGas> _ => _ </callGas>\n        <static> false </static>\n        <callDepth> VCallDepth => _ </callDepth>\n      </callState>\n      <substate>\n        <selfDestruct> VSelfDestruct </selfDestruct>\n        <log> _ => VLog </log>\n        <refund> _ => VRefund </refund>\n      </substate>\n      <gasPrice> _ </gasPrice>\n      <origin> ORIGIN_ID </origin>\n      <previousHash> _ </previousHash>\n      <ommersHash> _ </ommersHash>\n      <coinbase> _ </coinbase>\n      <stateRoot> _ </stateRoot>\n      <transactionsRoot> _ </transactionsRoot>\n      <receiptsRoot> _ </receiptsRoot>\n      <logsBloom> _ </logsBloom>\n      <difficulty> _ </difficulty>\n      <number> _ </number>\n      <gasLimit> _ </gasLimit>\n      <gasUsed> _ </gasUsed>\n      <timestamp> TIME </timestamp>\n      <extraData> _ </extraData>\n      <mixHash> _ </mixHash>\n      <blockNonce> _ </blockNonce>\n      <ommerBlockHeaders> _ </ommerBlockHeaders>\n      <blockhash> _ </blockhash>\n    </evm>\n    <network>\n      <activeAccounts> SetItem(ACCT_ID)\n      SetItem(1)\n      SetItem(2)\n      SetItem(3)\n      SetItem(4)\n      SetItem(5)\n      SetItem(6)\n      SetItem(7)\n      SetItem(8) _ </activeAccounts>\n      <accounts>\n        <account>\n          <acctID> ACCT_ID </acctID>\n          <balance> ACCT_ID_balance </balance>\n          <code> StandardToken_bin_runtime </code>\n          <storage>         \n           .Map \n          [#StandardToken.balances[ABI_from] <- (FromBal  => _)]        \n          [#StandardToken.balances[ABI_to] <- (ToBal    => _)]        \n          [#StandardToken.approvals[ABI_from][CALLER_ID] <- (Approval => _)]\n            _:Map \n           </storage>\n          <origStorage> _ </origStorage>\n          <nonce> _ </nonce>\n        </account>\n        <account>\n          <acctID> 1 </acctID>\n          <balance> ECREC_BAL </balance>\n          <code> .WordStack </code>\n          <storage> _:Map </storage>\n          <origStorage> _ </origStorage>\n          <nonce> _ </nonce>\n        </account>\n        <account>\n          <acctID> 2 </acctID>\n          <balance> SHA256_BAL </balance>\n          <code> .WordStack </code>\n          <storage> _:Map </storage>\n          <origStorage> _ </origStorage>\n          <nonce> _ </nonce>\n        </account>\n        <account>\n          <acctID> 3 </acctID>\n          <balance> RIP160_BAL </balance>\n          <code> .WordStack </code>\n          <storage> _:Map </storage>\n          <origStorage> _ </origStorage>\n          <nonce> _ </nonce>\n        </account>\n        <account>\n          <acctID> 4 </acctID>\n          <balance> ID_BAL </balance>\n          <code> .WordStack </code>\n          <storage> _:Map </storage>\n          <origStorage> _ </origStorage>\n          <nonce> _ </nonce>\n        </account>\n        <account>\n          <acctID> 5 </acctID>\n          <balance> MODEXP_BAL </balance>\n          <code> .WordStack </code>\n          <storage> _:Map </storage>\n          <origStorage> _ </origStorage>\n          <nonce> _ </nonce>\n        </account>\n        <account>\n          <acctID> 6 </acctID>\n          <balance> ECADD_BAL </balance>\n          <code> .WordStack </code>\n          <storage> _:Map </storage>\n          <origStorage> _ </origStorage>\n          <nonce> _ </nonce>\n        </account>\n        <account>\n          <acctID> 7 </acctID>\n          <balance> ECMUL_BAL </balance>\n          <code> .WordStack </code>\n          <storage> _:Map </storage>\n          <origStorage> _ </origStorage>\n          <nonce> _ </nonce>\n        </account>\n        <account>\n          <acctID> 8 </acctID>\n          <balance> ECPAIRING_BAL </balance>\n          <code> .WordStack </code>\n          <storage> _:Map </storage>\n          <origStorage> _ </origStorage>\n          <nonce> _ </nonce>\n        </account>\n       ... \n      </accounts>\n      <txOrder> _ </txOrder>\n      <txPending> _ </txPending>\n      <messages> _ </messages>\n    </network>\n  </ethereum>\nrequires #rangeAddress(ACCT_ID)\nandBool #notPrecompileAddress(ACCT_ID)\nandBool #rangeAddress(CALLER_ID)\nandBool #rangeAddress(ORIGIN_ID)\nandBool #rangeUInt(256, TIME)\nandBool #rangeUInt(256, ACCT_ID_balance)\nandBool #rangeUInt(256, ECREC_BAL)\nandBool #rangeUInt(256, SHA256_BAL)\nandBool #rangeUInt(256, RIP160_BAL)\nandBool #rangeUInt(256, ID_BAL)\nandBool #rangeUInt(256, MODEXP_BAL)\nandBool #rangeUInt(256, ECADD_BAL)\nandBool #rangeUInt(256, ECMUL_BAL)\nandBool #rangeUInt(256, ECPAIRING_BAL)\nandBool VCallDepth <=Int 1024\nandBool #rangeUInt(256, VCallValue)\n\n  andBool (#rangeAddress(ABI_from)\n  andBool (#rangeAddress(ABI_to)\n  andBool (#rangeUInt(256, ABI_value)\n  andBool (#rangeUInt(256, Approval)\n  andBool (#rangeUInt(256, FromBal)\n  andBool (#rangeUInt(256, ToBal)\n  andBool ((#sizeWordStack(CD) <=Int 1250000000)\n  andBool ((FromBal >=Int ABI_value)\n  andBool ((Approval >=Int ABI_value)\n  andBool ((ABI_value >Int 0)\n  andBool ((CALLER_ID =/=Int ABI_to)\n  andBool ((ABI_from =/=Int ABI_to)\n  andBool (VGas >=Int 3000000)))))))))))))\n  andBool notBool (\n    (((#rangeUInt(256, FromBal:Int -Int ABI_value:Int)))\n    andBool (((#rangeUInt(256, ToBal:Int +Int ABI_value:Int)))\n    andBool (((#rangeUInt(256, Approval:Int -Int ABI_value:Int)))\n    andBool ((VCallValue:Int ==Int 0)))))\n  ) \nensures\nFAILURE =/=K EVMC_SUCCESS","v2n":{"ACCT_ID":"StandardToken"},"act_name":"StandardToken_transferFrom.act","imports":[],"closed":true,"ctx":[],"module":"requires \"../rules.k\"\nrequires \"../bin_runtime.k\"\n\nmodule F68F10A60D24F4C786386B0AB04D1EF1AC0B1615DEF1D09710831E6DB42DA44E\n  imports ETHEREUM-SIMULATION\n  imports EVM\n  imports RULES\n  imports BIN_RUNTIME\n\n// StandardToken_transferFrom\nrule [StandardToken.transferFrom.fail.rough]:\n  <k> #execute ~> CONTINUATION => #halt ~> CONTINUATION </k>\n  <exit-code> 1 </exit-code>\n  <mode> NORMAL </mode>\n  <schedule> PETERSBURG </schedule>\n  <ethereum>\n    <evm>\n      <output> _ => _ </output>\n      <statusCode> _ => FAILURE:EndStatusCode </statusCode>\n      <callStack> VCallStack </callStack>\n      <interimStates> _ </interimStates>\n      <touchedAccounts> _ => _ </touchedAccounts>\n      <callState>\n        <program> #asMapOpCodes(#dasmOpCodes(StandardToken_bin_runtime, PETERSBURG)) </program>\n        <programBytes> StandardToken_bin_runtime </programBytes>\n        <id> ACCT_ID </id>\n        <caller> CALLER_ID </caller>\n        <callData> #abiCallData(\"transferFrom\", #address(ABI_from), #address(ABI_to), #uint256(ABI_value)) ++ CD => _ </callData>\n        <callValue> VCallValue </callValue>\n        <wordStack> .WordStack => _ </wordStack>\n        <localMem> .Map => _ </localMem>\n        <pc> 0 => _ </pc>\n        <gas> VGas => _ </gas>\n        <memoryUsed> 0 => _ </memoryUsed>\n        <callGas> _ => _ </callGas>\n        <static> false </static>\n        <callDepth> VCallDepth => _ </callDepth>\n      </callState>\n      <substate>\n        <selfDestruct> VSelfDestruct </selfDestruct>\n        <log> _ => VLog </log>\n        <refund> _ => VRefund </refund>\n      </substate>\n      <gasPrice> _ </gasPrice>\n      <origin> ORIGIN_ID </origin>\n      <previousHash> _ </previousHash>\n      <ommersHash> _ </ommersHash>\n      <coinbase> _ </coinbase>\n      <stateRoot> _ </stateRoot>\n      <transactionsRoot> _ </transactionsRoot>\n      <receiptsRoot> _ </receiptsRoot>\n      <logsBloom> _ </logsBloom>\n      <difficulty> _ </difficulty>\n      <number> _ </number>\n      <gasLimit> _ </gasLimit>\n      <gasUsed> _ </gasUsed>\n      <timestamp> TIME </timestamp>\n      <extraData> _ </extraData>\n      <mixHash> _ </mixHash>\n      <blockNonce> _ </blockNonce>\n      <ommerBlockHeaders> _ </ommerBlockHeaders>\n      <blockhash> _ </blockhash>\n    </evm>\n    <network>\n      <activeAccounts> SetItem(ACCT_ID)\n      SetItem(1)\n      SetItem(2)\n      SetItem(3)\n      SetItem(4)\n      SetItem(5)\n      SetItem(6)\n      SetItem(7)\n      SetItem(8) _ </activeAccounts>\n      <accounts>\n        <account>\n          <acctID> ACCT_ID </acctID>\n          <balance> ACCT_ID_balance </balance>\n          <code> StandardToken_bin_runtime </code>\n          <storage>         \n           .Map \n          [#StandardToken.balances[ABI_from] <- (FromBal  => _)]        \n          [#StandardToken.balances[ABI_to] <- (ToBal    => _)]        \n          [#StandardToken.approvals[ABI_from][CALLER_ID] <- (Approval => _)]\n            _:Map \n           </storage>\n          <origStorage> _ </origStorage>\n          <nonce> _ </nonce>\n        </account>\n        <account>\n          <acctID> 1 </acctID>\n          <balance> ECREC_BAL </balance>\n          <code> .WordStack </code>\n          <storage> _:Map </storage>\n          <origStorage> _ </origStorage>\n          <nonce> _ </nonce>\n        </account>\n        <account>\n          <acctID> 2 </acctID>\n          <balance> SHA256_BAL </balance>\n          <code> .WordStack </code>\n          <storage> _:Map </storage>\n          <origStorage> _ </origStorage>\n          <nonce> _ </nonce>\n        </account>\n        <account>\n          <acctID> 3 </acctID>\n          <balance> RIP160_BAL </balance>\n          <code> .WordStack </code>\n          <storage> _:Map </storage>\n          <origStorage> _ </origStorage>\n          <nonce> _ </nonce>\n        </account>\n        <account>\n          <acctID> 4 </acctID>\n          <balance> ID_BAL </balance>\n          <code> .WordStack </code>\n          <storage> _:Map </storage>\n          <origStorage> _ </origStorage>\n          <nonce> _ </nonce>\n        </account>\n        <account>\n          <acctID> 5 </acctID>\n          <balance> MODEXP_BAL </balance>\n          <code> .WordStack </code>\n          <storage> _:Map </storage>\n          <origStorage> _ </origStorage>\n          <nonce> _ </nonce>\n        </account>\n        <account>\n          <acctID> 6 </acctID>\n          <balance> ECADD_BAL </balance>\n          <code> .WordStack </code>\n          <storage> _:Map </storage>\n          <origStorage> _ </origStorage>\n          <nonce> _ </nonce>\n        </account>\n        <account>\n          <acctID> 7 </acctID>\n          <balance> ECMUL_BAL </balance>\n          <code> .WordStack </code>\n          <storage> _:Map </storage>\n          <origStorage> _ </origStorage>\n          <nonce> _ </nonce>\n        </account>\n        <account>\n          <acctID> 8 </acctID>\n          <balance> ECPAIRING_BAL </balance>\n          <code> .WordStack </code>\n          <storage> _:Map </storage>\n          <origStorage> _ </origStorage>\n          <nonce> _ </nonce>\n        </account>\n       ... \n      </accounts>\n      <txOrder> _ </txOrder>\n      <txPending> _ </txPending>\n      <messages> _ </messages>\n    </network>\n  </ethereum>\nrequires #rangeAddress(ACCT_ID)\nandBool #notPrecompileAddress(ACCT_ID)\nandBool #rangeAddress(CALLER_ID)\nandBool #rangeAddress(ORIGIN_ID)\nandBool #rangeUInt(256, TIME)\nandBool #rangeUInt(256, ACCT_ID_balance)\nandBool #rangeUInt(256, ECREC_BAL)\nandBool #rangeUInt(256, SHA256_BAL)\nandBool #rangeUInt(256, RIP160_BAL)\nandBool #rangeUInt(256, ID_BAL)\nandBool #rangeUInt(256, MODEXP_BAL)\nandBool #rangeUInt(256, ECADD_BAL)\nandBool #rangeUInt(256, ECMUL_BAL)\nandBool #rangeUInt(256, ECPAIRING_BAL)\nandBool VCallDepth <=Int 1024\nandBool #rangeUInt(256, VCallValue)\n\n  andBool (#rangeAddress(ABI_from)\n  andBool (#rangeAddress(ABI_to)\n  andBool (#rangeUInt(256, ABI_value)\n  andBool (#rangeUInt(256, Approval)\n  andBool (#rangeUInt(256, FromBal)\n  andBool (#rangeUInt(256, ToBal)\n  andBool ((#sizeWordStack(CD) <=Int 1250000000)\n  andBool ((FromBal >=Int ABI_value)\n  andBool ((Approval >=Int ABI_value)\n  andBool ((ABI_value >Int 0)\n  andBool ((CALLER_ID =/=Int ABI_to)\n  andBool ((ABI_from =/=Int ABI_to)\n  andBool (VGas >=Int 3000000)))))))))))))\n  andBool notBool (\n    (((#rangeUInt(256, FromBal:Int -Int ABI_value:Int)))\n    andBool (((#rangeUInt(256, ToBal:Int +Int ABI_value:Int)))\n    andBool (((#rangeUInt(256, Approval:Int -Int ABI_value:Int)))\n    andBool ((VCallValue:Int ==Int 0)))))\n  ) \nensures\nFAILURE =/=K EVMC_SUCCESS\n\nendmodule\n","hash":"f68f10a60d24f4c786386b0ab04d1ef1ac0b1615def1d09710831e6db42da44e","status":"????"}],"text":"<div id=\"StandardToken_transferFrom(address,address,uint256)\"><div class=\"codeheader\">\n      <a class=\"anchor\" href=\"#StandardToken_transferFrom(address,address,uint256)\">⚓</a>\n      <a class=\"jumptop\" href=\"#top\">top</a>\n    </div><pre><code>behaviour transferFrom of StandardToken\ninterface transferFrom(address from, address to, uint256 value)\n\ntypes\n  Approval : uint256\n  FromBal  : uint256\n  ToBal    : uint256\n\nstorage\n  <span class=\"comment\">// </span>\n  balances[from]             |-> FromBal  => FromBal - value\n  <span class=\"comment\">// </span>\n  balances[to]               |-> ToBal    => ToBal + value\n  <span class=\"comment\">// </span>\n  approvals[from][CALLER_ID] |-> Approval => Approval - value\n\niff in range uint256\n  FromBal - value\n  ToBal + value\n  Approval - value\n\niff\n  VCallValue == 0\n\nif\n  FromBal >= value\n  Approval >= value\n  value > 0\n  CALLER_ID =/= to\n  from =/= to\n\nreturns 1</code></pre></div>"},{"type":"paragraph","text":"TransferFrom Fail"},{"type":"code","lang":"act","obj":{"isStatic":false,"name":"transferFrom_fail","subject":"StandardToken","varname2alias":{"ACCT_ID":"StandardToken"},"act_name":"StandardToken_transferFrom_fail.act","internal":false,"sig":"transferFrom(address,address,uint256)","callData":"#abiCallData(\"transferFrom\", #address(ABI_from), #address(ABI_to), #uint256(ABI_value)) ++ CD","signature":"transferFrom(address,address,uint256)","types":{"ABI_from":"address","ABI_to":"address","ABI_value":"uint256","Approval":"uint256","FromBal":"uint256","ToBal":"uint256"},"if":["(#sizeWordStack(CD) <=Int 1250000000)","((FromBal <Int ABI_value orBool Approval <Int ABI_value orBool ABI_value ==Int 0))","(CALLER_ID =/=Int ABI_to)","(ABI_from =/=Int ABI_to)"],"interface":[["address","from"],["address","to"],["uint256","value"]],"fname":"transferFrom","storage":{"ACCT_ID":{"balances[from]":["FromBal ","FromBal - value"],"balances[to]":["ToBal   ","ToBal + value"],"approvals[from][CALLER_ID]":["Approval","Approval - value"]}},"iff":["((#rangeUInt(256, FromBal -Int ABI_value)))","((#rangeUInt(256, ToBal +Int ABI_value)))","((#rangeUInt(256, Approval -Int ABI_value)))","(VCallValue ==Int 0)"],"iff_orig":["VCallValue == 0"],"if_orig":["(FromBal < value or Approval < value or value == 0)","CALLER_ID =/= to","from =/= to"],"returns":["0"]},"cases":[{"act":{"isStatic":false,"name":"transferFrom_fail","subject":"StandardToken","varname2alias":{"ACCT_ID":"StandardToken"},"act_name":"StandardToken_transferFrom_fail.act","internal":false,"sig":"transferFrom(address,address,uint256)","callData":"#abiCallData(\"transferFrom\", #address(ABI_from), #address(ABI_to), #uint256(ABI_value)) ++ CD","signature":"transferFrom(address,address,uint256)","types":{"ABI_from":"address","ABI_to":"address","ABI_value":"uint256","Approval":"uint256","FromBal":"uint256","ToBal":"uint256"},"if":["(#sizeWordStack(CD) <=Int 1250000000)","((FromBal <Int ABI_value orBool Approval <Int ABI_value orBool ABI_value ==Int 0))","(CALLER_ID =/=Int ABI_to)","(ABI_from =/=Int ABI_to)"],"interface":[["address","from"],["address","to"],["uint256","value"]],"fname":"transferFrom","storage":{"ACCT_ID":{"balances[from]":["FromBal ","FromBal - value"],"balances[to]":["ToBal   ","ToBal + value"],"approvals[from][CALLER_ID]":["Approval","Approval - value"]}},"iff":["((#rangeUInt(256, FromBal -Int ABI_value)))","((#rangeUInt(256, ToBal +Int ABI_value)))","((#rangeUInt(256, Approval -Int ABI_value)))","(VCallValue ==Int 0)"],"iff_orig":["VCallValue == 0"],"if_orig":["(FromBal < value or Approval < value or value == 0)","CALLER_ID =/= to","from =/= to"],"returns":["0"]},"name":"StandardToken_transferFrom_fail_pass_rough","pass":true,"rough":true,"oog":false,"splitNumber":-1,"gas":[3000000],"hasGas":false,"spec":"// StandardToken_transferFrom_fail\nrule [StandardToken.transferFrom.fail.pass.rough]:\n  <k> #execute ~> CONTINUATION => #halt ~> CONTINUATION </k>\n  <exit-code> 1 </exit-code>\n  <mode> NORMAL </mode>\n  <schedule> PETERSBURG </schedule>\n  <ethereum>\n    <evm>\n      <output> _ => #asByteStackInWidthaux(0, 31, 32, .WordStack) </output>\n      <statusCode> _ => EVMC_SUCCESS </statusCode>\n      <callStack> VCallStack </callStack>\n      <interimStates> _ </interimStates>\n      <touchedAccounts> _ => _ </touchedAccounts>\n      <callState>\n        <program> #asMapOpCodes(#dasmOpCodes(StandardToken_bin_runtime, PETERSBURG)) </program>\n        <programBytes> StandardToken_bin_runtime </programBytes>\n        <id> ACCT_ID </id>\n        <caller> CALLER_ID </caller>\n        <callData> #abiCallData(\"transferFrom\", #address(ABI_from), #address(ABI_to), #uint256(ABI_value)) ++ CD => _ </callData>\n        <callValue> VCallValue </callValue>\n        <wordStack> .WordStack => _ </wordStack>\n        <localMem> .Map => _ </localMem>\n        <pc> 0 => _ </pc>\n        <gas> VGas => _ </gas>\n        <memoryUsed> 0 => _ </memoryUsed>\n        <callGas> _ => _ </callGas>\n        <static> false </static>\n        <callDepth> VCallDepth </callDepth>\n      </callState>\n      <substate>\n        <selfDestruct> VSelfDestruct </selfDestruct>\n        <log> _ => VLog </log>\n        <refund> _ => VRefund </refund>\n      </substate>\n      <gasPrice> _ </gasPrice>\n      <origin> ORIGIN_ID </origin>\n      <previousHash> _ </previousHash>\n      <ommersHash> _ </ommersHash>\n      <coinbase> _ </coinbase>\n      <stateRoot> _ </stateRoot>\n      <transactionsRoot> _ </transactionsRoot>\n      <receiptsRoot> _ </receiptsRoot>\n      <logsBloom> _ </logsBloom>\n      <difficulty> _ </difficulty>\n      <number> _ </number>\n      <gasLimit> _ </gasLimit>\n      <gasUsed> _ </gasUsed>\n      <timestamp> TIME </timestamp>\n      <extraData> _ </extraData>\n      <mixHash> _ </mixHash>\n      <blockNonce> _ </blockNonce>\n      <ommerBlockHeaders> _ </ommerBlockHeaders>\n      <blockhash> _ </blockhash>\n    </evm>\n    <network>\n      <activeAccounts> SetItem(ACCT_ID)\n      SetItem(1)\n      SetItem(2)\n      SetItem(3)\n      SetItem(4)\n      SetItem(5)\n      SetItem(6)\n      SetItem(7)\n      SetItem(8) _ </activeAccounts>\n      <accounts>\n        <account>\n          <acctID> ACCT_ID </acctID>\n          <balance> ACCT_ID_balance </balance>\n          <code> StandardToken_bin_runtime </code>\n          <storage>         \n           .Map \n          [#StandardToken.balances[ABI_from] <- (FromBal  => FromBal -Int ABI_value)]        \n          [#StandardToken.balances[ABI_to] <- (ToBal    => ToBal +Int ABI_value)]        \n          [#StandardToken.approvals[ABI_from][CALLER_ID] <- (Approval => Approval -Int ABI_value)]\n            _:Map \n           </storage>\n          <origStorage> _ </origStorage>\n          <nonce> _ </nonce>\n        </account>\n        <account>\n          <acctID> 1 </acctID>\n          <balance> ECREC_BAL </balance>\n          <code> .WordStack </code>\n          <storage> _:Map </storage>\n          <origStorage> _ </origStorage>\n          <nonce> _ </nonce>\n        </account>\n        <account>\n          <acctID> 2 </acctID>\n          <balance> SHA256_BAL </balance>\n          <code> .WordStack </code>\n          <storage> _:Map </storage>\n          <origStorage> _ </origStorage>\n          <nonce> _ </nonce>\n        </account>\n        <account>\n          <acctID> 3 </acctID>\n          <balance> RIP160_BAL </balance>\n          <code> .WordStack </code>\n          <storage> _:Map </storage>\n          <origStorage> _ </origStorage>\n          <nonce> _ </nonce>\n        </account>\n        <account>\n          <acctID> 4 </acctID>\n          <balance> ID_BAL </balance>\n          <code> .WordStack </code>\n          <storage> _:Map </storage>\n          <origStorage> _ </origStorage>\n          <nonce> _ </nonce>\n        </account>\n        <account>\n          <acctID> 5 </acctID>\n          <balance> MODEXP_BAL </balance>\n          <code> .WordStack </code>\n          <storage> _:Map </storage>\n          <origStorage> _ </origStorage>\n          <nonce> _ </nonce>\n        </account>\n        <account>\n          <acctID> 6 </acctID>\n          <balance> ECADD_BAL </balance>\n          <code> .WordStack </code>\n          <storage> _:Map </storage>\n          <origStorage> _ </origStorage>\n          <nonce> _ </nonce>\n        </account>\n        <account>\n          <acctID> 7 </acctID>\n          <balance> ECMUL_BAL </balance>\n          <code> .WordStack </code>\n          <storage> _:Map </storage>\n          <origStorage> _ </origStorage>\n          <nonce> _ </nonce>\n        </account>\n        <account>\n          <acctID> 8 </acctID>\n          <balance> ECPAIRING_BAL </balance>\n          <code> .WordStack </code>\n          <storage> _:Map </storage>\n          <origStorage> _ </origStorage>\n          <nonce> _ </nonce>\n        </account>\n       ... \n      </accounts>\n      <txOrder> _ </txOrder>\n      <txPending> _ </txPending>\n      <messages> _ </messages>\n    </network>\n  </ethereum>\nrequires #rangeAddress(ACCT_ID)\nandBool #notPrecompileAddress(ACCT_ID)\nandBool #rangeAddress(CALLER_ID)\nandBool #rangeAddress(ORIGIN_ID)\nandBool #rangeUInt(256, TIME)\nandBool #rangeUInt(256, ACCT_ID_balance)\nandBool #rangeUInt(256, ECREC_BAL)\nandBool #rangeUInt(256, SHA256_BAL)\nandBool #rangeUInt(256, RIP160_BAL)\nandBool #rangeUInt(256, ID_BAL)\nandBool #rangeUInt(256, MODEXP_BAL)\nandBool #rangeUInt(256, ECADD_BAL)\nandBool #rangeUInt(256, ECMUL_BAL)\nandBool #rangeUInt(256, ECPAIRING_BAL)\nandBool VCallDepth <=Int 1024\nandBool #rangeUInt(256, VCallValue)\n\n  andBool (#rangeAddress(ABI_from)\n  andBool (#rangeAddress(ABI_to)\n  andBool (#rangeUInt(256, ABI_value)\n  andBool (#rangeUInt(256, Approval)\n  andBool (#rangeUInt(256, FromBal)\n  andBool (#rangeUInt(256, ToBal)\n  andBool ((#sizeWordStack(CD) <=Int 1250000000)\n  andBool (((FromBal <Int ABI_value orBool Approval <Int ABI_value orBool ABI_value ==Int 0))\n  andBool ((CALLER_ID =/=Int ABI_to)\n  andBool ((ABI_from =/=Int ABI_to)\n  andBool (VGas >=Int 3000000\n  andBool (((#rangeUInt(256, FromBal -Int ABI_value)))\n  andBool (((#rangeUInt(256, ToBal +Int ABI_value)))\n  andBool (((#rangeUInt(256, Approval -Int ABI_value)))\n  andBool ((VCallValue ==Int 0)))))))))))))))) ","v2n":{"ACCT_ID":"StandardToken"},"act_name":"StandardToken_transferFrom_fail.act","imports":[],"closed":true,"ctx":[],"module":"requires \"../rules.k\"\nrequires \"../bin_runtime.k\"\n\nmodule 2DB6AE4E3C353FBFED19EA305423CE0B53C8ED211295F06E7213790B65BB9D9D\n  imports ETHEREUM-SIMULATION\n  imports EVM\n  imports RULES\n  imports BIN_RUNTIME\n\n// StandardToken_transferFrom_fail\nrule [StandardToken.transferFrom.fail.pass.rough]:\n  <k> #execute ~> CONTINUATION => #halt ~> CONTINUATION </k>\n  <exit-code> 1 </exit-code>\n  <mode> NORMAL </mode>\n  <schedule> PETERSBURG </schedule>\n  <ethereum>\n    <evm>\n      <output> _ => #asByteStackInWidthaux(0, 31, 32, .WordStack) </output>\n      <statusCode> _ => EVMC_SUCCESS </statusCode>\n      <callStack> VCallStack </callStack>\n      <interimStates> _ </interimStates>\n      <touchedAccounts> _ => _ </touchedAccounts>\n      <callState>\n        <program> #asMapOpCodes(#dasmOpCodes(StandardToken_bin_runtime, PETERSBURG)) </program>\n        <programBytes> StandardToken_bin_runtime </programBytes>\n        <id> ACCT_ID </id>\n        <caller> CALLER_ID </caller>\n        <callData> #abiCallData(\"transferFrom\", #address(ABI_from), #address(ABI_to), #uint256(ABI_value)) ++ CD => _ </callData>\n        <callValue> VCallValue </callValue>\n        <wordStack> .WordStack => _ </wordStack>\n        <localMem> .Map => _ </localMem>\n        <pc> 0 => _ </pc>\n        <gas> VGas => _ </gas>\n        <memoryUsed> 0 => _ </memoryUsed>\n        <callGas> _ => _ </callGas>\n        <static> false </static>\n        <callDepth> VCallDepth </callDepth>\n      </callState>\n      <substate>\n        <selfDestruct> VSelfDestruct </selfDestruct>\n        <log> _ => VLog </log>\n        <refund> _ => VRefund </refund>\n      </substate>\n      <gasPrice> _ </gasPrice>\n      <origin> ORIGIN_ID </origin>\n      <previousHash> _ </previousHash>\n      <ommersHash> _ </ommersHash>\n      <coinbase> _ </coinbase>\n      <stateRoot> _ </stateRoot>\n      <transactionsRoot> _ </transactionsRoot>\n      <receiptsRoot> _ </receiptsRoot>\n      <logsBloom> _ </logsBloom>\n      <difficulty> _ </difficulty>\n      <number> _ </number>\n      <gasLimit> _ </gasLimit>\n      <gasUsed> _ </gasUsed>\n      <timestamp> TIME </timestamp>\n      <extraData> _ </extraData>\n      <mixHash> _ </mixHash>\n      <blockNonce> _ </blockNonce>\n      <ommerBlockHeaders> _ </ommerBlockHeaders>\n      <blockhash> _ </blockhash>\n    </evm>\n    <network>\n      <activeAccounts> SetItem(ACCT_ID)\n      SetItem(1)\n      SetItem(2)\n      SetItem(3)\n      SetItem(4)\n      SetItem(5)\n      SetItem(6)\n      SetItem(7)\n      SetItem(8) _ </activeAccounts>\n      <accounts>\n        <account>\n          <acctID> ACCT_ID </acctID>\n          <balance> ACCT_ID_balance </balance>\n          <code> StandardToken_bin_runtime </code>\n          <storage>         \n           .Map \n          [#StandardToken.balances[ABI_from] <- (FromBal  => FromBal -Int ABI_value)]        \n          [#StandardToken.balances[ABI_to] <- (ToBal    => ToBal +Int ABI_value)]        \n          [#StandardToken.approvals[ABI_from][CALLER_ID] <- (Approval => Approval -Int ABI_value)]\n            _:Map \n           </storage>\n          <origStorage> _ </origStorage>\n          <nonce> _ </nonce>\n        </account>\n        <account>\n          <acctID> 1 </acctID>\n          <balance> ECREC_BAL </balance>\n          <code> .WordStack </code>\n          <storage> _:Map </storage>\n          <origStorage> _ </origStorage>\n          <nonce> _ </nonce>\n        </account>\n        <account>\n          <acctID> 2 </acctID>\n          <balance> SHA256_BAL </balance>\n          <code> .WordStack </code>\n          <storage> _:Map </storage>\n          <origStorage> _ </origStorage>\n          <nonce> _ </nonce>\n        </account>\n        <account>\n          <acctID> 3 </acctID>\n          <balance> RIP160_BAL </balance>\n          <code> .WordStack </code>\n          <storage> _:Map </storage>\n          <origStorage> _ </origStorage>\n          <nonce> _ </nonce>\n        </account>\n        <account>\n          <acctID> 4 </acctID>\n          <balance> ID_BAL </balance>\n          <code> .WordStack </code>\n          <storage> _:Map </storage>\n          <origStorage> _ </origStorage>\n          <nonce> _ </nonce>\n        </account>\n        <account>\n          <acctID> 5 </acctID>\n          <balance> MODEXP_BAL </balance>\n          <code> .WordStack </code>\n          <storage> _:Map </storage>\n          <origStorage> _ </origStorage>\n          <nonce> _ </nonce>\n        </account>\n        <account>\n          <acctID> 6 </acctID>\n          <balance> ECADD_BAL </balance>\n          <code> .WordStack </code>\n          <storage> _:Map </storage>\n          <origStorage> _ </origStorage>\n          <nonce> _ </nonce>\n        </account>\n        <account>\n          <acctID> 7 </acctID>\n          <balance> ECMUL_BAL </balance>\n          <code> .WordStack </code>\n          <storage> _:Map </storage>\n          <origStorage> _ </origStorage>\n          <nonce> _ </nonce>\n        </account>\n        <account>\n          <acctID> 8 </acctID>\n          <balance> ECPAIRING_BAL </balance>\n          <code> .WordStack </code>\n          <storage> _:Map </storage>\n          <origStorage> _ </origStorage>\n          <nonce> _ </nonce>\n        </account>\n       ... \n      </accounts>\n      <txOrder> _ </txOrder>\n      <txPending> _ </txPending>\n      <messages> _ </messages>\n    </network>\n  </ethereum>\nrequires #rangeAddress(ACCT_ID)\nandBool #notPrecompileAddress(ACCT_ID)\nandBool #rangeAddress(CALLER_ID)\nandBool #rangeAddress(ORIGIN_ID)\nandBool #rangeUInt(256, TIME)\nandBool #rangeUInt(256, ACCT_ID_balance)\nandBool #rangeUInt(256, ECREC_BAL)\nandBool #rangeUInt(256, SHA256_BAL)\nandBool #rangeUInt(256, RIP160_BAL)\nandBool #rangeUInt(256, ID_BAL)\nandBool #rangeUInt(256, MODEXP_BAL)\nandBool #rangeUInt(256, ECADD_BAL)\nandBool #rangeUInt(256, ECMUL_BAL)\nandBool #rangeUInt(256, ECPAIRING_BAL)\nandBool VCallDepth <=Int 1024\nandBool #rangeUInt(256, VCallValue)\n\n  andBool (#rangeAddress(ABI_from)\n  andBool (#rangeAddress(ABI_to)\n  andBool (#rangeUInt(256, ABI_value)\n  andBool (#rangeUInt(256, Approval)\n  andBool (#rangeUInt(256, FromBal)\n  andBool (#rangeUInt(256, ToBal)\n  andBool ((#sizeWordStack(CD) <=Int 1250000000)\n  andBool (((FromBal <Int ABI_value orBool Approval <Int ABI_value orBool ABI_value ==Int 0))\n  andBool ((CALLER_ID =/=Int ABI_to)\n  andBool ((ABI_from =/=Int ABI_to)\n  andBool (VGas >=Int 3000000\n  andBool (((#rangeUInt(256, FromBal -Int ABI_value)))\n  andBool (((#rangeUInt(256, ToBal +Int ABI_value)))\n  andBool (((#rangeUInt(256, Approval -Int ABI_value)))\n  andBool ((VCallValue ==Int 0)))))))))))))))) \n\nendmodule\n","hash":"2db6ae4e3c353fbfed19ea305423ce0b53c8ed211295f06e7213790b65bb9d9d","status":"????"},{"act":{"isStatic":false,"name":"transferFrom_fail","subject":"StandardToken","varname2alias":{"ACCT_ID":"StandardToken"},"act_name":"StandardToken_transferFrom_fail.act","internal":false,"sig":"transferFrom(address,address,uint256)","callData":"#abiCallData(\"transferFrom\", #address(ABI_from), #address(ABI_to), #uint256(ABI_value)) ++ CD","signature":"transferFrom(address,address,uint256)","types":{"ABI_from":"address","ABI_to":"address","ABI_value":"uint256","Approval":"uint256","FromBal":"uint256","ToBal":"uint256"},"if":["(#sizeWordStack(CD) <=Int 1250000000)","((FromBal <Int ABI_value orBool Approval <Int ABI_value orBool ABI_value ==Int 0))","(CALLER_ID =/=Int ABI_to)","(ABI_from =/=Int ABI_to)"],"interface":[["address","from"],["address","to"],["uint256","value"]],"fname":"transferFrom","storage":{"ACCT_ID":{"balances[from]":["FromBal ","FromBal - value"],"balances[to]":["ToBal   ","ToBal + value"],"approvals[from][CALLER_ID]":["Approval","Approval - value"]}},"iff":["((#rangeUInt(256, FromBal -Int ABI_value)))","((#rangeUInt(256, ToBal +Int ABI_value)))","((#rangeUInt(256, Approval -Int ABI_value)))","(VCallValue ==Int 0)"],"iff_orig":["VCallValue == 0"],"if_orig":["(FromBal < value or Approval < value or value == 0)","CALLER_ID =/= to","from =/= to"],"returns":["0"],"ensures":["FAILURE =/=K EVMC_SUCCESS"]},"pass":false,"splitNumber":-1,"gas":3000000,"oog":false,"name":"StandardToken_transferFrom_fail_fail_rough","spec":"// StandardToken_transferFrom_fail\nrule [StandardToken.transferFrom.fail.fail.rough]:\n  <k> #execute ~> CONTINUATION => #halt ~> CONTINUATION </k>\n  <exit-code> 1 </exit-code>\n  <mode> NORMAL </mode>\n  <schedule> PETERSBURG </schedule>\n  <ethereum>\n    <evm>\n      <output> _ => _ </output>\n      <statusCode> _ => FAILURE:EndStatusCode </statusCode>\n      <callStack> VCallStack </callStack>\n      <interimStates> _ </interimStates>\n      <touchedAccounts> _ => _ </touchedAccounts>\n      <callState>\n        <program> #asMapOpCodes(#dasmOpCodes(StandardToken_bin_runtime, PETERSBURG)) </program>\n        <programBytes> StandardToken_bin_runtime </programBytes>\n        <id> ACCT_ID </id>\n        <caller> CALLER_ID </caller>\n        <callData> #abiCallData(\"transferFrom\", #address(ABI_from), #address(ABI_to), #uint256(ABI_value)) ++ CD => _ </callData>\n        <callValue> VCallValue </callValue>\n        <wordStack> .WordStack => _ </wordStack>\n        <localMem> .Map => _ </localMem>\n        <pc> 0 => _ </pc>\n        <gas> VGas => _ </gas>\n        <memoryUsed> 0 => _ </memoryUsed>\n        <callGas> _ => _ </callGas>\n        <static> false </static>\n        <callDepth> VCallDepth => _ </callDepth>\n      </callState>\n      <substate>\n        <selfDestruct> VSelfDestruct </selfDestruct>\n        <log> _ => VLog </log>\n        <refund> _ => VRefund </refund>\n      </substate>\n      <gasPrice> _ </gasPrice>\n      <origin> ORIGIN_ID </origin>\n      <previousHash> _ </previousHash>\n      <ommersHash> _ </ommersHash>\n      <coinbase> _ </coinbase>\n      <stateRoot> _ </stateRoot>\n      <transactionsRoot> _ </transactionsRoot>\n      <receiptsRoot> _ </receiptsRoot>\n      <logsBloom> _ </logsBloom>\n      <difficulty> _ </difficulty>\n      <number> _ </number>\n      <gasLimit> _ </gasLimit>\n      <gasUsed> _ </gasUsed>\n      <timestamp> TIME </timestamp>\n      <extraData> _ </extraData>\n      <mixHash> _ </mixHash>\n      <blockNonce> _ </blockNonce>\n      <ommerBlockHeaders> _ </ommerBlockHeaders>\n      <blockhash> _ </blockhash>\n    </evm>\n    <network>\n      <activeAccounts> SetItem(ACCT_ID)\n      SetItem(1)\n      SetItem(2)\n      SetItem(3)\n      SetItem(4)\n      SetItem(5)\n      SetItem(6)\n      SetItem(7)\n      SetItem(8) _ </activeAccounts>\n      <accounts>\n        <account>\n          <acctID> ACCT_ID </acctID>\n          <balance> ACCT_ID_balance </balance>\n          <code> StandardToken_bin_runtime </code>\n          <storage>         \n           .Map \n          [#StandardToken.balances[ABI_from] <- (FromBal  => _)]        \n          [#StandardToken.balances[ABI_to] <- (ToBal    => _)]        \n          [#StandardToken.approvals[ABI_from][CALLER_ID] <- (Approval => _)]\n            _:Map \n           </storage>\n          <origStorage> _ </origStorage>\n          <nonce> _ </nonce>\n        </account>\n        <account>\n          <acctID> 1 </acctID>\n          <balance> ECREC_BAL </balance>\n          <code> .WordStack </code>\n          <storage> _:Map </storage>\n          <origStorage> _ </origStorage>\n          <nonce> _ </nonce>\n        </account>\n        <account>\n          <acctID> 2 </acctID>\n          <balance> SHA256_BAL </balance>\n          <code> .WordStack </code>\n          <storage> _:Map </storage>\n          <origStorage> _ </origStorage>\n          <nonce> _ </nonce>\n        </account>\n        <account>\n          <acctID> 3 </acctID>\n          <balance> RIP160_BAL </balance>\n          <code> .WordStack </code>\n          <storage> _:Map </storage>\n          <origStorage> _ </origStorage>\n          <nonce> _ </nonce>\n        </account>\n        <account>\n          <acctID> 4 </acctID>\n          <balance> ID_BAL </balance>\n          <code> .WordStack </code>\n          <storage> _:Map </storage>\n          <origStorage> _ </origStorage>\n          <nonce> _ </nonce>\n        </account>\n        <account>\n          <acctID> 5 </acctID>\n          <balance> MODEXP_BAL </balance>\n          <code> .WordStack </code>\n          <storage> _:Map </storage>\n          <origStorage> _ </origStorage>\n          <nonce> _ </nonce>\n        </account>\n        <account>\n          <acctID> 6 </acctID>\n          <balance> ECADD_BAL </balance>\n          <code> .WordStack </code>\n          <storage> _:Map </storage>\n          <origStorage> _ </origStorage>\n          <nonce> _ </nonce>\n        </account>\n        <account>\n          <acctID> 7 </acctID>\n          <balance> ECMUL_BAL </balance>\n          <code> .WordStack </code>\n          <storage> _:Map </storage>\n          <origStorage> _ </origStorage>\n          <nonce> _ </nonce>\n        </account>\n        <account>\n          <acctID> 8 </acctID>\n          <balance> ECPAIRING_BAL </balance>\n          <code> .WordStack </code>\n          <storage> _:Map </storage>\n          <origStorage> _ </origStorage>\n          <nonce> _ </nonce>\n        </account>\n       ... \n      </accounts>\n      <txOrder> _ </txOrder>\n      <txPending> _ </txPending>\n      <messages> _ </messages>\n    </network>\n  </ethereum>\nrequires #rangeAddress(ACCT_ID)\nandBool #notPrecompileAddress(ACCT_ID)\nandBool #rangeAddress(CALLER_ID)\nandBool #rangeAddress(ORIGIN_ID)\nandBool #rangeUInt(256, TIME)\nandBool #rangeUInt(256, ACCT_ID_balance)\nandBool #rangeUInt(256, ECREC_BAL)\nandBool #rangeUInt(256, SHA256_BAL)\nandBool #rangeUInt(256, RIP160_BAL)\nandBool #rangeUInt(256, ID_BAL)\nandBool #rangeUInt(256, MODEXP_BAL)\nandBool #rangeUInt(256, ECADD_BAL)\nandBool #rangeUInt(256, ECMUL_BAL)\nandBool #rangeUInt(256, ECPAIRING_BAL)\nandBool VCallDepth <=Int 1024\nandBool #rangeUInt(256, VCallValue)\n\n  andBool (#rangeAddress(ABI_from)\n  andBool (#rangeAddress(ABI_to)\n  andBool (#rangeUInt(256, ABI_value)\n  andBool (#rangeUInt(256, Approval)\n  andBool (#rangeUInt(256, FromBal)\n  andBool (#rangeUInt(256, ToBal)\n  andBool ((#sizeWordStack(CD) <=Int 1250000000)\n  andBool (((FromBal <Int ABI_value orBool Approval <Int ABI_value orBool ABI_value ==Int 0))\n  andBool ((CALLER_ID =/=Int ABI_to)\n  andBool ((ABI_from =/=Int ABI_to)\n  andBool (VGas >=Int 3000000)))))))))))\n  andBool notBool (\n    (((#rangeUInt(256, FromBal:Int -Int ABI_value:Int)))\n    andBool (((#rangeUInt(256, ToBal:Int +Int ABI_value:Int)))\n    andBool (((#rangeUInt(256, Approval:Int -Int ABI_value:Int)))\n    andBool ((VCallValue:Int ==Int 0)))))\n  ) \nensures\nFAILURE =/=K EVMC_SUCCESS","v2n":{"ACCT_ID":"StandardToken"},"act_name":"StandardToken_transferFrom_fail.act","imports":[],"closed":true,"ctx":[],"module":"requires \"../rules.k\"\nrequires \"../bin_runtime.k\"\n\nmodule 36DE7279DD1B0834565B04D77CAE130D613622CEFFEAF60867473E6D991BBFE1\n  imports ETHEREUM-SIMULATION\n  imports EVM\n  imports RULES\n  imports BIN_RUNTIME\n\n// StandardToken_transferFrom_fail\nrule [StandardToken.transferFrom.fail.fail.rough]:\n  <k> #execute ~> CONTINUATION => #halt ~> CONTINUATION </k>\n  <exit-code> 1 </exit-code>\n  <mode> NORMAL </mode>\n  <schedule> PETERSBURG </schedule>\n  <ethereum>\n    <evm>\n      <output> _ => _ </output>\n      <statusCode> _ => FAILURE:EndStatusCode </statusCode>\n      <callStack> VCallStack </callStack>\n      <interimStates> _ </interimStates>\n      <touchedAccounts> _ => _ </touchedAccounts>\n      <callState>\n        <program> #asMapOpCodes(#dasmOpCodes(StandardToken_bin_runtime, PETERSBURG)) </program>\n        <programBytes> StandardToken_bin_runtime </programBytes>\n        <id> ACCT_ID </id>\n        <caller> CALLER_ID </caller>\n        <callData> #abiCallData(\"transferFrom\", #address(ABI_from), #address(ABI_to), #uint256(ABI_value)) ++ CD => _ </callData>\n        <callValue> VCallValue </callValue>\n        <wordStack> .WordStack => _ </wordStack>\n        <localMem> .Map => _ </localMem>\n        <pc> 0 => _ </pc>\n        <gas> VGas => _ </gas>\n        <memoryUsed> 0 => _ </memoryUsed>\n        <callGas> _ => _ </callGas>\n        <static> false </static>\n        <callDepth> VCallDepth => _ </callDepth>\n      </callState>\n      <substate>\n        <selfDestruct> VSelfDestruct </selfDestruct>\n        <log> _ => VLog </log>\n        <refund> _ => VRefund </refund>\n      </substate>\n      <gasPrice> _ </gasPrice>\n      <origin> ORIGIN_ID </origin>\n      <previousHash> _ </previousHash>\n      <ommersHash> _ </ommersHash>\n      <coinbase> _ </coinbase>\n      <stateRoot> _ </stateRoot>\n      <transactionsRoot> _ </transactionsRoot>\n      <receiptsRoot> _ </receiptsRoot>\n      <logsBloom> _ </logsBloom>\n      <difficulty> _ </difficulty>\n      <number> _ </number>\n      <gasLimit> _ </gasLimit>\n      <gasUsed> _ </gasUsed>\n      <timestamp> TIME </timestamp>\n      <extraData> _ </extraData>\n      <mixHash> _ </mixHash>\n      <blockNonce> _ </blockNonce>\n      <ommerBlockHeaders> _ </ommerBlockHeaders>\n      <blockhash> _ </blockhash>\n    </evm>\n    <network>\n      <activeAccounts> SetItem(ACCT_ID)\n      SetItem(1)\n      SetItem(2)\n      SetItem(3)\n      SetItem(4)\n      SetItem(5)\n      SetItem(6)\n      SetItem(7)\n      SetItem(8) _ </activeAccounts>\n      <accounts>\n        <account>\n          <acctID> ACCT_ID </acctID>\n          <balance> ACCT_ID_balance </balance>\n          <code> StandardToken_bin_runtime </code>\n          <storage>         \n           .Map \n          [#StandardToken.balances[ABI_from] <- (FromBal  => _)]        \n          [#StandardToken.balances[ABI_to] <- (ToBal    => _)]        \n          [#StandardToken.approvals[ABI_from][CALLER_ID] <- (Approval => _)]\n            _:Map \n           </storage>\n          <origStorage> _ </origStorage>\n          <nonce> _ </nonce>\n        </account>\n        <account>\n          <acctID> 1 </acctID>\n          <balance> ECREC_BAL </balance>\n          <code> .WordStack </code>\n          <storage> _:Map </storage>\n          <origStorage> _ </origStorage>\n          <nonce> _ </nonce>\n        </account>\n        <account>\n          <acctID> 2 </acctID>\n          <balance> SHA256_BAL </balance>\n          <code> .WordStack </code>\n          <storage> _:Map </storage>\n          <origStorage> _ </origStorage>\n          <nonce> _ </nonce>\n        </account>\n        <account>\n          <acctID> 3 </acctID>\n          <balance> RIP160_BAL </balance>\n          <code> .WordStack </code>\n          <storage> _:Map </storage>\n          <origStorage> _ </origStorage>\n          <nonce> _ </nonce>\n        </account>\n        <account>\n          <acctID> 4 </acctID>\n          <balance> ID_BAL </balance>\n          <code> .WordStack </code>\n          <storage> _:Map </storage>\n          <origStorage> _ </origStorage>\n          <nonce> _ </nonce>\n        </account>\n        <account>\n          <acctID> 5 </acctID>\n          <balance> MODEXP_BAL </balance>\n          <code> .WordStack </code>\n          <storage> _:Map </storage>\n          <origStorage> _ </origStorage>\n          <nonce> _ </nonce>\n        </account>\n        <account>\n          <acctID> 6 </acctID>\n          <balance> ECADD_BAL </balance>\n          <code> .WordStack </code>\n          <storage> _:Map </storage>\n          <origStorage> _ </origStorage>\n          <nonce> _ </nonce>\n        </account>\n        <account>\n          <acctID> 7 </acctID>\n          <balance> ECMUL_BAL </balance>\n          <code> .WordStack </code>\n          <storage> _:Map </storage>\n          <origStorage> _ </origStorage>\n          <nonce> _ </nonce>\n        </account>\n        <account>\n          <acctID> 8 </acctID>\n          <balance> ECPAIRING_BAL </balance>\n          <code> .WordStack </code>\n          <storage> _:Map </storage>\n          <origStorage> _ </origStorage>\n          <nonce> _ </nonce>\n        </account>\n       ... \n      </accounts>\n      <txOrder> _ </txOrder>\n      <txPending> _ </txPending>\n      <messages> _ </messages>\n    </network>\n  </ethereum>\nrequires #rangeAddress(ACCT_ID)\nandBool #notPrecompileAddress(ACCT_ID)\nandBool #rangeAddress(CALLER_ID)\nandBool #rangeAddress(ORIGIN_ID)\nandBool #rangeUInt(256, TIME)\nandBool #rangeUInt(256, ACCT_ID_balance)\nandBool #rangeUInt(256, ECREC_BAL)\nandBool #rangeUInt(256, SHA256_BAL)\nandBool #rangeUInt(256, RIP160_BAL)\nandBool #rangeUInt(256, ID_BAL)\nandBool #rangeUInt(256, MODEXP_BAL)\nandBool #rangeUInt(256, ECADD_BAL)\nandBool #rangeUInt(256, ECMUL_BAL)\nandBool #rangeUInt(256, ECPAIRING_BAL)\nandBool VCallDepth <=Int 1024\nandBool #rangeUInt(256, VCallValue)\n\n  andBool (#rangeAddress(ABI_from)\n  andBool (#rangeAddress(ABI_to)\n  andBool (#rangeUInt(256, ABI_value)\n  andBool (#rangeUInt(256, Approval)\n  andBool (#rangeUInt(256, FromBal)\n  andBool (#rangeUInt(256, ToBal)\n  andBool ((#sizeWordStack(CD) <=Int 1250000000)\n  andBool (((FromBal <Int ABI_value orBool Approval <Int ABI_value orBool ABI_value ==Int 0))\n  andBool ((CALLER_ID =/=Int ABI_to)\n  andBool ((ABI_from =/=Int ABI_to)\n  andBool (VGas >=Int 3000000)))))))))))\n  andBool notBool (\n    (((#rangeUInt(256, FromBal:Int -Int ABI_value:Int)))\n    andBool (((#rangeUInt(256, ToBal:Int +Int ABI_value:Int)))\n    andBool (((#rangeUInt(256, Approval:Int -Int ABI_value:Int)))\n    andBool ((VCallValue:Int ==Int 0)))))\n  ) \nensures\nFAILURE =/=K EVMC_SUCCESS\n\nendmodule\n","hash":"36de7279dd1b0834565b04d77cae130d613622ceffeaf60867473e6d991bbfe1","status":"????"}],"text":"<div id=\"StandardToken_transferFrom(address,address,uint256)\"><div class=\"codeheader\">\n      <a class=\"anchor\" href=\"#StandardToken_transferFrom(address,address,uint256)\">⚓</a>\n      <a class=\"jumptop\" href=\"#top\">top</a>\n    </div><pre><code>behaviour transferFrom_fail of StandardToken\ninterface transferFrom(address from, address to, uint256 value)\n\ntypes\n  Approval : uint256\n  FromBal  : uint256\n  ToBal    : uint256\n\nstorage\n  <span class=\"comment\">// </span>\n  balances[from]             |-> FromBal  => FromBal - value\n  <span class=\"comment\">// </span>\n  balances[to]               |-> ToBal    => ToBal + value\n  <span class=\"comment\">// </span>\n  approvals[from][CALLER_ID] |-> Approval => Approval - value\n\niff in range uint256\n  FromBal - value\n  ToBal + value\n  Approval - value\n\niff\n  VCallValue == 0\n\nif\n  (FromBal < value or Approval < value or value == 0)\n  CALLER_ID =/= to\n  from =/= to\n\nreturns 0</code></pre></div>"}]