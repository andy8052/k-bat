[{"type":"code","lang":"act","obj":{"isStatic":false,"name":"transferFrom","subject":"StandardToken","varname2alias":{"ACCT_ID":"StandardToken"},"act_name":"StandardToken_transferFrom.act","internal":false,"sig":"transferFrom(address,address,uint256)","callData":"#abiCallData(\"transferFrom\", #address(ABI_from), #address(ABI_to), #uint256(ABI_value)) ++ CD","signature":"transferFrom(address,address,uint256)","types":{"ABI_from":"address","ABI_to":"address","ABI_value":"uint256","Approval":"uint256","FromBal":"uint256","ToBal":"uint256","Paused":"uint8","Filler":"uint8","Fillerr":"uint8","Fillerrr":"address"},"if":["(#sizeWordStack(CD) <=Int 1250000000)","(#notPrecompileAddress(Fillerrr))","(ABI_from =/=Int ABI_to)"],"interface":[["address","from"],["address","to"],["uint256","value"]],"fname":"transferFrom","storage":{"ACCT_ID":{"balances[from]":["FromBal                                                        ","FromBal - value"],"balances[to]":["ToBal                                                          ","ToBal + value"],"approvals[from][CALLER_ID]":["Approval                                                       ","Approval - value"],"filler_fillerr_paused_fillerrr":["#WordPackUInt8UInt8UInt8Addr(Filler, Fillerr, Paused, Fillerrr)","#WordPackUInt8UInt8UInt8Addr(Filler, Fillerr, Paused, Fillerrr)"]}},"iff":["((#rangeUInt(256, FromBal -Int ABI_value)))","((#rangeUInt(256, ToBal +Int ABI_value)))","((#rangeUInt(256, Approval -Int ABI_value)))","(Paused ==Int 0)","(VCallValue ==Int 0)","(ABI_to =/=Int 0)"],"iff_orig":["Paused == 0","VCallValue == 0","to =/= 0"],"if_orig":["from =/= to"],"returns":["1"]},"cases":[{"act":{"isStatic":false,"name":"transferFrom","subject":"StandardToken","varname2alias":{"ACCT_ID":"StandardToken"},"act_name":"StandardToken_transferFrom.act","internal":false,"sig":"transferFrom(address,address,uint256)","callData":"#abiCallData(\"transferFrom\", #address(ABI_from), #address(ABI_to), #uint256(ABI_value)) ++ CD","signature":"transferFrom(address,address,uint256)","types":{"ABI_from":"address","ABI_to":"address","ABI_value":"uint256","Approval":"uint256","FromBal":"uint256","ToBal":"uint256","Paused":"uint8","Filler":"uint8","Fillerr":"uint8","Fillerrr":"address"},"if":["(#sizeWordStack(CD) <=Int 1250000000)","(#notPrecompileAddress(Fillerrr))","(ABI_from =/=Int ABI_to)"],"interface":[["address","from"],["address","to"],["uint256","value"]],"fname":"transferFrom","storage":{"ACCT_ID":{"balances[from]":["FromBal                                                        ","FromBal - value"],"balances[to]":["ToBal                                                          ","ToBal + value"],"approvals[from][CALLER_ID]":["Approval                                                       ","Approval - value"],"filler_fillerr_paused_fillerrr":["#WordPackUInt8UInt8UInt8Addr(Filler, Fillerr, Paused, Fillerrr)","#WordPackUInt8UInt8UInt8Addr(Filler, Fillerr, Paused, Fillerrr)"]}},"iff":["((#rangeUInt(256, FromBal -Int ABI_value)))","((#rangeUInt(256, ToBal +Int ABI_value)))","((#rangeUInt(256, Approval -Int ABI_value)))","(Paused ==Int 0)","(VCallValue ==Int 0)","(ABI_to =/=Int 0)"],"iff_orig":["Paused == 0","VCallValue == 0","to =/= 0"],"if_orig":["from =/= to"],"returns":["1"]},"name":"StandardToken_transferFrom_pass_rough","pass":true,"rough":true,"oog":false,"splitNumber":-1,"gas":[3000000],"hasGas":false,"spec":"// StandardToken_transferFrom\nrule [StandardToken.transferFrom.pass.rough]:\n  <k> #execute ~> CONTINUATION => #halt ~> CONTINUATION </k>\n  <exit-code> 1 </exit-code>\n  <mode> NORMAL </mode>\n  <schedule> PETERSBURG </schedule>\n  <ethereum>\n    <evm>\n      <output> _ => #asByteStackInWidthaux(1, 31, 32, .WordStack) </output>\n      <statusCode> _ => EVMC_SUCCESS </statusCode>\n      <callStack> VCallStack </callStack>\n      <interimStates> _ </interimStates>\n      <touchedAccounts> _ => _ </touchedAccounts>\n      <callState>\n        <program> #asMapOpCodes(#dasmOpCodes(StandardToken_bin_runtime, PETERSBURG)) </program>\n        <programBytes> StandardToken_bin_runtime </programBytes>\n        <id> ACCT_ID </id>\n        <caller> CALLER_ID </caller>\n        <callData> #abiCallData(\"transferFrom\", #address(ABI_from), #address(ABI_to), #uint256(ABI_value)) ++ CD => _ </callData>\n        <callValue> VCallValue </callValue>\n        <wordStack> .WordStack => _ </wordStack>\n        <localMem> .Map => _ </localMem>\n        <pc> 0 => _ </pc>\n        <gas> VGas => _ </gas>\n        <memoryUsed> 0 => _ </memoryUsed>\n        <callGas> _ => _ </callGas>\n        <static> false </static>\n        <callDepth> VCallDepth </callDepth>\n      </callState>\n      <substate>\n        <selfDestruct> VSelfDestruct </selfDestruct>\n        <log> _ => VLog </log>\n        <refund> _ => VRefund </refund>\n      </substate>\n      <gasPrice> _ </gasPrice>\n      <origin> ORIGIN_ID </origin>\n      <previousHash> _ </previousHash>\n      <ommersHash> _ </ommersHash>\n      <coinbase> _ </coinbase>\n      <stateRoot> _ </stateRoot>\n      <transactionsRoot> _ </transactionsRoot>\n      <receiptsRoot> _ </receiptsRoot>\n      <logsBloom> _ </logsBloom>\n      <difficulty> _ </difficulty>\n      <number> _ </number>\n      <gasLimit> _ </gasLimit>\n      <gasUsed> _ </gasUsed>\n      <timestamp> TIME </timestamp>\n      <extraData> _ </extraData>\n      <mixHash> _ </mixHash>\n      <blockNonce> _ </blockNonce>\n      <ommerBlockHeaders> _ </ommerBlockHeaders>\n      <blockhash> _ </blockhash>\n    </evm>\n    <network>\n      <activeAccounts> SetItem(ACCT_ID)\n      SetItem(1)\n      SetItem(2)\n      SetItem(3)\n      SetItem(4)\n      SetItem(5)\n      SetItem(6)\n      SetItem(7)\n      SetItem(8) _ </activeAccounts>\n      <accounts>\n        <account>\n          <acctID> ACCT_ID </acctID>\n          <balance> ACCT_ID_balance </balance>\n          <code> StandardToken_bin_runtime </code>\n          <storage>         \n           .Map \n          [#StandardToken.balances[ABI_from] <- (FromBal                                                         => FromBal -Int ABI_value)]        \n          [#StandardToken.balances[ABI_to] <- (ToBal                                                           => ToBal +Int ABI_value)]        \n          [#StandardToken.approvals[ABI_from][CALLER_ID] <- (Approval                                                        => Approval -Int ABI_value)]        \n          [#StandardToken.filler_fillerr_paused_fillerrr <- (#WordPackUInt8UInt8UInt8Addr(Filler, Fillerr, Paused, Fillerrr) => #WordPackUInt8UInt8UInt8Addr(Filler, Fillerr, Paused, Fillerrr))]\n            _:Map \n           </storage>\n          <origStorage> _ </origStorage>\n          <nonce> _ </nonce>\n        </account>\n        <account>\n          <acctID> 1 </acctID>\n          <balance> ECREC_BAL </balance>\n          <code> .WordStack </code>\n          <storage> _:Map </storage>\n          <origStorage> _ </origStorage>\n          <nonce> _ </nonce>\n        </account>\n        <account>\n          <acctID> 2 </acctID>\n          <balance> SHA256_BAL </balance>\n          <code> .WordStack </code>\n          <storage> _:Map </storage>\n          <origStorage> _ </origStorage>\n          <nonce> _ </nonce>\n        </account>\n        <account>\n          <acctID> 3 </acctID>\n          <balance> RIP160_BAL </balance>\n          <code> .WordStack </code>\n          <storage> _:Map </storage>\n          <origStorage> _ </origStorage>\n          <nonce> _ </nonce>\n        </account>\n        <account>\n          <acctID> 4 </acctID>\n          <balance> ID_BAL </balance>\n          <code> .WordStack </code>\n          <storage> _:Map </storage>\n          <origStorage> _ </origStorage>\n          <nonce> _ </nonce>\n        </account>\n        <account>\n          <acctID> 5 </acctID>\n          <balance> MODEXP_BAL </balance>\n          <code> .WordStack </code>\n          <storage> _:Map </storage>\n          <origStorage> _ </origStorage>\n          <nonce> _ </nonce>\n        </account>\n        <account>\n          <acctID> 6 </acctID>\n          <balance> ECADD_BAL </balance>\n          <code> .WordStack </code>\n          <storage> _:Map </storage>\n          <origStorage> _ </origStorage>\n          <nonce> _ </nonce>\n        </account>\n        <account>\n          <acctID> 7 </acctID>\n          <balance> ECMUL_BAL </balance>\n          <code> .WordStack </code>\n          <storage> _:Map </storage>\n          <origStorage> _ </origStorage>\n          <nonce> _ </nonce>\n        </account>\n        <account>\n          <acctID> 8 </acctID>\n          <balance> ECPAIRING_BAL </balance>\n          <code> .WordStack </code>\n          <storage> _:Map </storage>\n          <origStorage> _ </origStorage>\n          <nonce> _ </nonce>\n        </account>\n       ... \n      </accounts>\n      <txOrder> _ </txOrder>\n      <txPending> _ </txPending>\n      <messages> _ </messages>\n    </network>\n  </ethereum>\nrequires #rangeAddress(ACCT_ID)\nandBool #notPrecompileAddress(ACCT_ID)\nandBool #rangeAddress(CALLER_ID)\nandBool #rangeAddress(ORIGIN_ID)\nandBool #rangeUInt(256, TIME)\nandBool #rangeUInt(256, ACCT_ID_balance)\nandBool #rangeUInt(256, ECREC_BAL)\nandBool #rangeUInt(256, SHA256_BAL)\nandBool #rangeUInt(256, RIP160_BAL)\nandBool #rangeUInt(256, ID_BAL)\nandBool #rangeUInt(256, MODEXP_BAL)\nandBool #rangeUInt(256, ECADD_BAL)\nandBool #rangeUInt(256, ECMUL_BAL)\nandBool #rangeUInt(256, ECPAIRING_BAL)\nandBool VCallDepth <=Int 1024\nandBool #rangeUInt(256, VCallValue)\n\n  andBool (#rangeAddress(ABI_from)\n  andBool (#rangeAddress(ABI_to)\n  andBool (#rangeUInt(256, ABI_value)\n  andBool (#rangeUInt(256, Approval)\n  andBool (#rangeUInt(256, FromBal)\n  andBool (#rangeUInt(256, ToBal)\n  andBool (#rangeUInt(8, Paused)\n  andBool (#rangeUInt(8, Filler)\n  andBool (#rangeUInt(8, Fillerr)\n  andBool (#rangeAddress(Fillerrr)\n  andBool ((#sizeWordStack(CD) <=Int 1250000000)\n  andBool ((#notPrecompileAddress(Fillerrr))\n  andBool ((ABI_from =/=Int ABI_to)\n  andBool (VGas >=Int 3000000\n  andBool (((#rangeUInt(256, FromBal -Int ABI_value)))\n  andBool (((#rangeUInt(256, ToBal +Int ABI_value)))\n  andBool (((#rangeUInt(256, Approval -Int ABI_value)))\n  andBool ((Paused ==Int 0)\n  andBool ((VCallValue ==Int 0)\n  andBool ((ABI_to =/=Int 0))))))))))))))))))))) ","v2n":{"ACCT_ID":"StandardToken"},"act_name":"StandardToken_transferFrom.act","imports":[],"closed":true,"ctx":[],"module":"requires \"../rules.k\"\nrequires \"../bin_runtime.k\"\n\nmodule 6F631DE8D83E5CE1D204B1E679ADD253CE3A9EE411EC40FF217C6E21CD5EA682\n  imports ETHEREUM-SIMULATION\n  imports EVM\n  imports RULES\n  imports BIN_RUNTIME\n\n// StandardToken_transferFrom\nrule [StandardToken.transferFrom.pass.rough]:\n  <k> #execute ~> CONTINUATION => #halt ~> CONTINUATION </k>\n  <exit-code> 1 </exit-code>\n  <mode> NORMAL </mode>\n  <schedule> PETERSBURG </schedule>\n  <ethereum>\n    <evm>\n      <output> _ => #asByteStackInWidthaux(1, 31, 32, .WordStack) </output>\n      <statusCode> _ => EVMC_SUCCESS </statusCode>\n      <callStack> VCallStack </callStack>\n      <interimStates> _ </interimStates>\n      <touchedAccounts> _ => _ </touchedAccounts>\n      <callState>\n        <program> #asMapOpCodes(#dasmOpCodes(StandardToken_bin_runtime, PETERSBURG)) </program>\n        <programBytes> StandardToken_bin_runtime </programBytes>\n        <id> ACCT_ID </id>\n        <caller> CALLER_ID </caller>\n        <callData> #abiCallData(\"transferFrom\", #address(ABI_from), #address(ABI_to), #uint256(ABI_value)) ++ CD => _ </callData>\n        <callValue> VCallValue </callValue>\n        <wordStack> .WordStack => _ </wordStack>\n        <localMem> .Map => _ </localMem>\n        <pc> 0 => _ </pc>\n        <gas> VGas => _ </gas>\n        <memoryUsed> 0 => _ </memoryUsed>\n        <callGas> _ => _ </callGas>\n        <static> false </static>\n        <callDepth> VCallDepth </callDepth>\n      </callState>\n      <substate>\n        <selfDestruct> VSelfDestruct </selfDestruct>\n        <log> _ => VLog </log>\n        <refund> _ => VRefund </refund>\n      </substate>\n      <gasPrice> _ </gasPrice>\n      <origin> ORIGIN_ID </origin>\n      <previousHash> _ </previousHash>\n      <ommersHash> _ </ommersHash>\n      <coinbase> _ </coinbase>\n      <stateRoot> _ </stateRoot>\n      <transactionsRoot> _ </transactionsRoot>\n      <receiptsRoot> _ </receiptsRoot>\n      <logsBloom> _ </logsBloom>\n      <difficulty> _ </difficulty>\n      <number> _ </number>\n      <gasLimit> _ </gasLimit>\n      <gasUsed> _ </gasUsed>\n      <timestamp> TIME </timestamp>\n      <extraData> _ </extraData>\n      <mixHash> _ </mixHash>\n      <blockNonce> _ </blockNonce>\n      <ommerBlockHeaders> _ </ommerBlockHeaders>\n      <blockhash> _ </blockhash>\n    </evm>\n    <network>\n      <activeAccounts> SetItem(ACCT_ID)\n      SetItem(1)\n      SetItem(2)\n      SetItem(3)\n      SetItem(4)\n      SetItem(5)\n      SetItem(6)\n      SetItem(7)\n      SetItem(8) _ </activeAccounts>\n      <accounts>\n        <account>\n          <acctID> ACCT_ID </acctID>\n          <balance> ACCT_ID_balance </balance>\n          <code> StandardToken_bin_runtime </code>\n          <storage>         \n           .Map \n          [#StandardToken.balances[ABI_from] <- (FromBal                                                         => FromBal -Int ABI_value)]        \n          [#StandardToken.balances[ABI_to] <- (ToBal                                                           => ToBal +Int ABI_value)]        \n          [#StandardToken.approvals[ABI_from][CALLER_ID] <- (Approval                                                        => Approval -Int ABI_value)]        \n          [#StandardToken.filler_fillerr_paused_fillerrr <- (#WordPackUInt8UInt8UInt8Addr(Filler, Fillerr, Paused, Fillerrr) => #WordPackUInt8UInt8UInt8Addr(Filler, Fillerr, Paused, Fillerrr))]\n            _:Map \n           </storage>\n          <origStorage> _ </origStorage>\n          <nonce> _ </nonce>\n        </account>\n        <account>\n          <acctID> 1 </acctID>\n          <balance> ECREC_BAL </balance>\n          <code> .WordStack </code>\n          <storage> _:Map </storage>\n          <origStorage> _ </origStorage>\n          <nonce> _ </nonce>\n        </account>\n        <account>\n          <acctID> 2 </acctID>\n          <balance> SHA256_BAL </balance>\n          <code> .WordStack </code>\n          <storage> _:Map </storage>\n          <origStorage> _ </origStorage>\n          <nonce> _ </nonce>\n        </account>\n        <account>\n          <acctID> 3 </acctID>\n          <balance> RIP160_BAL </balance>\n          <code> .WordStack </code>\n          <storage> _:Map </storage>\n          <origStorage> _ </origStorage>\n          <nonce> _ </nonce>\n        </account>\n        <account>\n          <acctID> 4 </acctID>\n          <balance> ID_BAL </balance>\n          <code> .WordStack </code>\n          <storage> _:Map </storage>\n          <origStorage> _ </origStorage>\n          <nonce> _ </nonce>\n        </account>\n        <account>\n          <acctID> 5 </acctID>\n          <balance> MODEXP_BAL </balance>\n          <code> .WordStack </code>\n          <storage> _:Map </storage>\n          <origStorage> _ </origStorage>\n          <nonce> _ </nonce>\n        </account>\n        <account>\n          <acctID> 6 </acctID>\n          <balance> ECADD_BAL </balance>\n          <code> .WordStack </code>\n          <storage> _:Map </storage>\n          <origStorage> _ </origStorage>\n          <nonce> _ </nonce>\n        </account>\n        <account>\n          <acctID> 7 </acctID>\n          <balance> ECMUL_BAL </balance>\n          <code> .WordStack </code>\n          <storage> _:Map </storage>\n          <origStorage> _ </origStorage>\n          <nonce> _ </nonce>\n        </account>\n        <account>\n          <acctID> 8 </acctID>\n          <balance> ECPAIRING_BAL </balance>\n          <code> .WordStack </code>\n          <storage> _:Map </storage>\n          <origStorage> _ </origStorage>\n          <nonce> _ </nonce>\n        </account>\n       ... \n      </accounts>\n      <txOrder> _ </txOrder>\n      <txPending> _ </txPending>\n      <messages> _ </messages>\n    </network>\n  </ethereum>\nrequires #rangeAddress(ACCT_ID)\nandBool #notPrecompileAddress(ACCT_ID)\nandBool #rangeAddress(CALLER_ID)\nandBool #rangeAddress(ORIGIN_ID)\nandBool #rangeUInt(256, TIME)\nandBool #rangeUInt(256, ACCT_ID_balance)\nandBool #rangeUInt(256, ECREC_BAL)\nandBool #rangeUInt(256, SHA256_BAL)\nandBool #rangeUInt(256, RIP160_BAL)\nandBool #rangeUInt(256, ID_BAL)\nandBool #rangeUInt(256, MODEXP_BAL)\nandBool #rangeUInt(256, ECADD_BAL)\nandBool #rangeUInt(256, ECMUL_BAL)\nandBool #rangeUInt(256, ECPAIRING_BAL)\nandBool VCallDepth <=Int 1024\nandBool #rangeUInt(256, VCallValue)\n\n  andBool (#rangeAddress(ABI_from)\n  andBool (#rangeAddress(ABI_to)\n  andBool (#rangeUInt(256, ABI_value)\n  andBool (#rangeUInt(256, Approval)\n  andBool (#rangeUInt(256, FromBal)\n  andBool (#rangeUInt(256, ToBal)\n  andBool (#rangeUInt(8, Paused)\n  andBool (#rangeUInt(8, Filler)\n  andBool (#rangeUInt(8, Fillerr)\n  andBool (#rangeAddress(Fillerrr)\n  andBool ((#sizeWordStack(CD) <=Int 1250000000)\n  andBool ((#notPrecompileAddress(Fillerrr))\n  andBool ((ABI_from =/=Int ABI_to)\n  andBool (VGas >=Int 3000000\n  andBool (((#rangeUInt(256, FromBal -Int ABI_value)))\n  andBool (((#rangeUInt(256, ToBal +Int ABI_value)))\n  andBool (((#rangeUInt(256, Approval -Int ABI_value)))\n  andBool ((Paused ==Int 0)\n  andBool ((VCallValue ==Int 0)\n  andBool ((ABI_to =/=Int 0))))))))))))))))))))) \n\nendmodule\n","hash":"6f631de8d83e5ce1d204b1e679add253ce3a9ee411ec40ff217c6e21cd5ea682","status":"????"},{"act":{"isStatic":false,"name":"transferFrom","subject":"StandardToken","varname2alias":{"ACCT_ID":"StandardToken"},"act_name":"StandardToken_transferFrom.act","internal":false,"sig":"transferFrom(address,address,uint256)","callData":"#abiCallData(\"transferFrom\", #address(ABI_from), #address(ABI_to), #uint256(ABI_value)) ++ CD","signature":"transferFrom(address,address,uint256)","types":{"ABI_from":"address","ABI_to":"address","ABI_value":"uint256","Approval":"uint256","FromBal":"uint256","ToBal":"uint256","Paused":"uint8","Filler":"uint8","Fillerr":"uint8","Fillerrr":"address"},"if":["(#sizeWordStack(CD) <=Int 1250000000)","(#notPrecompileAddress(Fillerrr))","(ABI_from =/=Int ABI_to)"],"interface":[["address","from"],["address","to"],["uint256","value"]],"fname":"transferFrom","storage":{"ACCT_ID":{"balances[from]":["FromBal                                                        ","FromBal - value"],"balances[to]":["ToBal                                                          ","ToBal + value"],"approvals[from][CALLER_ID]":["Approval                                                       ","Approval - value"],"filler_fillerr_paused_fillerrr":["#WordPackUInt8UInt8UInt8Addr(Filler, Fillerr, Paused, Fillerrr)","#WordPackUInt8UInt8UInt8Addr(Filler, Fillerr, Paused, Fillerrr)"]}},"iff":["((#rangeUInt(256, FromBal -Int ABI_value)))","((#rangeUInt(256, ToBal +Int ABI_value)))","((#rangeUInt(256, Approval -Int ABI_value)))","(Paused ==Int 0)","(VCallValue ==Int 0)","(ABI_to =/=Int 0)"],"iff_orig":["Paused == 0","VCallValue == 0","to =/= 0"],"if_orig":["from =/= to"],"returns":["1"],"ensures":["FAILURE =/=K EVMC_SUCCESS"]},"pass":false,"splitNumber":-1,"gas":3000000,"oog":false,"name":"StandardToken_transferFrom_fail_rough","spec":"// StandardToken_transferFrom\nrule [StandardToken.transferFrom.fail.rough]:\n  <k> #execute ~> CONTINUATION => #halt ~> CONTINUATION </k>\n  <exit-code> 1 </exit-code>\n  <mode> NORMAL </mode>\n  <schedule> PETERSBURG </schedule>\n  <ethereum>\n    <evm>\n      <output> _ => _ </output>\n      <statusCode> _ => FAILURE:EndStatusCode </statusCode>\n      <callStack> VCallStack </callStack>\n      <interimStates> _ </interimStates>\n      <touchedAccounts> _ => _ </touchedAccounts>\n      <callState>\n        <program> #asMapOpCodes(#dasmOpCodes(StandardToken_bin_runtime, PETERSBURG)) </program>\n        <programBytes> StandardToken_bin_runtime </programBytes>\n        <id> ACCT_ID </id>\n        <caller> CALLER_ID </caller>\n        <callData> #abiCallData(\"transferFrom\", #address(ABI_from), #address(ABI_to), #uint256(ABI_value)) ++ CD => _ </callData>\n        <callValue> VCallValue </callValue>\n        <wordStack> .WordStack => _ </wordStack>\n        <localMem> .Map => _ </localMem>\n        <pc> 0 => _ </pc>\n        <gas> VGas => _ </gas>\n        <memoryUsed> 0 => _ </memoryUsed>\n        <callGas> _ => _ </callGas>\n        <static> false </static>\n        <callDepth> VCallDepth => _ </callDepth>\n      </callState>\n      <substate>\n        <selfDestruct> VSelfDestruct </selfDestruct>\n        <log> _ => VLog </log>\n        <refund> _ => VRefund </refund>\n      </substate>\n      <gasPrice> _ </gasPrice>\n      <origin> ORIGIN_ID </origin>\n      <previousHash> _ </previousHash>\n      <ommersHash> _ </ommersHash>\n      <coinbase> _ </coinbase>\n      <stateRoot> _ </stateRoot>\n      <transactionsRoot> _ </transactionsRoot>\n      <receiptsRoot> _ </receiptsRoot>\n      <logsBloom> _ </logsBloom>\n      <difficulty> _ </difficulty>\n      <number> _ </number>\n      <gasLimit> _ </gasLimit>\n      <gasUsed> _ </gasUsed>\n      <timestamp> TIME </timestamp>\n      <extraData> _ </extraData>\n      <mixHash> _ </mixHash>\n      <blockNonce> _ </blockNonce>\n      <ommerBlockHeaders> _ </ommerBlockHeaders>\n      <blockhash> _ </blockhash>\n    </evm>\n    <network>\n      <activeAccounts> SetItem(ACCT_ID)\n      SetItem(1)\n      SetItem(2)\n      SetItem(3)\n      SetItem(4)\n      SetItem(5)\n      SetItem(6)\n      SetItem(7)\n      SetItem(8) _ </activeAccounts>\n      <accounts>\n        <account>\n          <acctID> ACCT_ID </acctID>\n          <balance> ACCT_ID_balance </balance>\n          <code> StandardToken_bin_runtime </code>\n          <storage>         \n           .Map \n          [#StandardToken.balances[ABI_from] <- (FromBal                                                         => _)]        \n          [#StandardToken.balances[ABI_to] <- (ToBal                                                           => _)]        \n          [#StandardToken.approvals[ABI_from][CALLER_ID] <- (Approval                                                        => _)]        \n          [#StandardToken.filler_fillerr_paused_fillerrr <- (#WordPackUInt8UInt8UInt8Addr(Filler, Fillerr, Paused, Fillerrr) => _)]\n            _:Map \n           </storage>\n          <origStorage> _ </origStorage>\n          <nonce> _ </nonce>\n        </account>\n        <account>\n          <acctID> 1 </acctID>\n          <balance> ECREC_BAL </balance>\n          <code> .WordStack </code>\n          <storage> _:Map </storage>\n          <origStorage> _ </origStorage>\n          <nonce> _ </nonce>\n        </account>\n        <account>\n          <acctID> 2 </acctID>\n          <balance> SHA256_BAL </balance>\n          <code> .WordStack </code>\n          <storage> _:Map </storage>\n          <origStorage> _ </origStorage>\n          <nonce> _ </nonce>\n        </account>\n        <account>\n          <acctID> 3 </acctID>\n          <balance> RIP160_BAL </balance>\n          <code> .WordStack </code>\n          <storage> _:Map </storage>\n          <origStorage> _ </origStorage>\n          <nonce> _ </nonce>\n        </account>\n        <account>\n          <acctID> 4 </acctID>\n          <balance> ID_BAL </balance>\n          <code> .WordStack </code>\n          <storage> _:Map </storage>\n          <origStorage> _ </origStorage>\n          <nonce> _ </nonce>\n        </account>\n        <account>\n          <acctID> 5 </acctID>\n          <balance> MODEXP_BAL </balance>\n          <code> .WordStack </code>\n          <storage> _:Map </storage>\n          <origStorage> _ </origStorage>\n          <nonce> _ </nonce>\n        </account>\n        <account>\n          <acctID> 6 </acctID>\n          <balance> ECADD_BAL </balance>\n          <code> .WordStack </code>\n          <storage> _:Map </storage>\n          <origStorage> _ </origStorage>\n          <nonce> _ </nonce>\n        </account>\n        <account>\n          <acctID> 7 </acctID>\n          <balance> ECMUL_BAL </balance>\n          <code> .WordStack </code>\n          <storage> _:Map </storage>\n          <origStorage> _ </origStorage>\n          <nonce> _ </nonce>\n        </account>\n        <account>\n          <acctID> 8 </acctID>\n          <balance> ECPAIRING_BAL </balance>\n          <code> .WordStack </code>\n          <storage> _:Map </storage>\n          <origStorage> _ </origStorage>\n          <nonce> _ </nonce>\n        </account>\n       ... \n      </accounts>\n      <txOrder> _ </txOrder>\n      <txPending> _ </txPending>\n      <messages> _ </messages>\n    </network>\n  </ethereum>\nrequires #rangeAddress(ACCT_ID)\nandBool #notPrecompileAddress(ACCT_ID)\nandBool #rangeAddress(CALLER_ID)\nandBool #rangeAddress(ORIGIN_ID)\nandBool #rangeUInt(256, TIME)\nandBool #rangeUInt(256, ACCT_ID_balance)\nandBool #rangeUInt(256, ECREC_BAL)\nandBool #rangeUInt(256, SHA256_BAL)\nandBool #rangeUInt(256, RIP160_BAL)\nandBool #rangeUInt(256, ID_BAL)\nandBool #rangeUInt(256, MODEXP_BAL)\nandBool #rangeUInt(256, ECADD_BAL)\nandBool #rangeUInt(256, ECMUL_BAL)\nandBool #rangeUInt(256, ECPAIRING_BAL)\nandBool VCallDepth <=Int 1024\nandBool #rangeUInt(256, VCallValue)\n\n  andBool (#rangeAddress(ABI_from)\n  andBool (#rangeAddress(ABI_to)\n  andBool (#rangeUInt(256, ABI_value)\n  andBool (#rangeUInt(256, Approval)\n  andBool (#rangeUInt(256, FromBal)\n  andBool (#rangeUInt(256, ToBal)\n  andBool (#rangeUInt(8, Paused)\n  andBool (#rangeUInt(8, Filler)\n  andBool (#rangeUInt(8, Fillerr)\n  andBool (#rangeAddress(Fillerrr)\n  andBool ((#sizeWordStack(CD) <=Int 1250000000)\n  andBool ((#notPrecompileAddress(Fillerrr))\n  andBool ((ABI_from =/=Int ABI_to)\n  andBool (VGas >=Int 3000000))))))))))))))\n  andBool notBool (\n    (((#rangeUInt(256, FromBal:Int -Int ABI_value:Int)))\n    andBool (((#rangeUInt(256, ToBal:Int +Int ABI_value:Int)))\n    andBool (((#rangeUInt(256, Approval:Int -Int ABI_value:Int)))\n    andBool ((Paused:Int ==Int 0)\n    andBool ((VCallValue:Int ==Int 0)\n    andBool ((ABI_to:Int =/=Int 0)))))))\n  ) \nensures\nFAILURE =/=K EVMC_SUCCESS","v2n":{"ACCT_ID":"StandardToken"},"act_name":"StandardToken_transferFrom.act","imports":[],"closed":true,"ctx":[],"module":"requires \"../rules.k\"\nrequires \"../bin_runtime.k\"\n\nmodule 3172D5EA4D344A7B58795686591B78D8E7BA3328C73D2CD7FF295834B11348D5\n  imports ETHEREUM-SIMULATION\n  imports EVM\n  imports RULES\n  imports BIN_RUNTIME\n\n// StandardToken_transferFrom\nrule [StandardToken.transferFrom.fail.rough]:\n  <k> #execute ~> CONTINUATION => #halt ~> CONTINUATION </k>\n  <exit-code> 1 </exit-code>\n  <mode> NORMAL </mode>\n  <schedule> PETERSBURG </schedule>\n  <ethereum>\n    <evm>\n      <output> _ => _ </output>\n      <statusCode> _ => FAILURE:EndStatusCode </statusCode>\n      <callStack> VCallStack </callStack>\n      <interimStates> _ </interimStates>\n      <touchedAccounts> _ => _ </touchedAccounts>\n      <callState>\n        <program> #asMapOpCodes(#dasmOpCodes(StandardToken_bin_runtime, PETERSBURG)) </program>\n        <programBytes> StandardToken_bin_runtime </programBytes>\n        <id> ACCT_ID </id>\n        <caller> CALLER_ID </caller>\n        <callData> #abiCallData(\"transferFrom\", #address(ABI_from), #address(ABI_to), #uint256(ABI_value)) ++ CD => _ </callData>\n        <callValue> VCallValue </callValue>\n        <wordStack> .WordStack => _ </wordStack>\n        <localMem> .Map => _ </localMem>\n        <pc> 0 => _ </pc>\n        <gas> VGas => _ </gas>\n        <memoryUsed> 0 => _ </memoryUsed>\n        <callGas> _ => _ </callGas>\n        <static> false </static>\n        <callDepth> VCallDepth => _ </callDepth>\n      </callState>\n      <substate>\n        <selfDestruct> VSelfDestruct </selfDestruct>\n        <log> _ => VLog </log>\n        <refund> _ => VRefund </refund>\n      </substate>\n      <gasPrice> _ </gasPrice>\n      <origin> ORIGIN_ID </origin>\n      <previousHash> _ </previousHash>\n      <ommersHash> _ </ommersHash>\n      <coinbase> _ </coinbase>\n      <stateRoot> _ </stateRoot>\n      <transactionsRoot> _ </transactionsRoot>\n      <receiptsRoot> _ </receiptsRoot>\n      <logsBloom> _ </logsBloom>\n      <difficulty> _ </difficulty>\n      <number> _ </number>\n      <gasLimit> _ </gasLimit>\n      <gasUsed> _ </gasUsed>\n      <timestamp> TIME </timestamp>\n      <extraData> _ </extraData>\n      <mixHash> _ </mixHash>\n      <blockNonce> _ </blockNonce>\n      <ommerBlockHeaders> _ </ommerBlockHeaders>\n      <blockhash> _ </blockhash>\n    </evm>\n    <network>\n      <activeAccounts> SetItem(ACCT_ID)\n      SetItem(1)\n      SetItem(2)\n      SetItem(3)\n      SetItem(4)\n      SetItem(5)\n      SetItem(6)\n      SetItem(7)\n      SetItem(8) _ </activeAccounts>\n      <accounts>\n        <account>\n          <acctID> ACCT_ID </acctID>\n          <balance> ACCT_ID_balance </balance>\n          <code> StandardToken_bin_runtime </code>\n          <storage>         \n           .Map \n          [#StandardToken.balances[ABI_from] <- (FromBal                                                         => _)]        \n          [#StandardToken.balances[ABI_to] <- (ToBal                                                           => _)]        \n          [#StandardToken.approvals[ABI_from][CALLER_ID] <- (Approval                                                        => _)]        \n          [#StandardToken.filler_fillerr_paused_fillerrr <- (#WordPackUInt8UInt8UInt8Addr(Filler, Fillerr, Paused, Fillerrr) => _)]\n            _:Map \n           </storage>\n          <origStorage> _ </origStorage>\n          <nonce> _ </nonce>\n        </account>\n        <account>\n          <acctID> 1 </acctID>\n          <balance> ECREC_BAL </balance>\n          <code> .WordStack </code>\n          <storage> _:Map </storage>\n          <origStorage> _ </origStorage>\n          <nonce> _ </nonce>\n        </account>\n        <account>\n          <acctID> 2 </acctID>\n          <balance> SHA256_BAL </balance>\n          <code> .WordStack </code>\n          <storage> _:Map </storage>\n          <origStorage> _ </origStorage>\n          <nonce> _ </nonce>\n        </account>\n        <account>\n          <acctID> 3 </acctID>\n          <balance> RIP160_BAL </balance>\n          <code> .WordStack </code>\n          <storage> _:Map </storage>\n          <origStorage> _ </origStorage>\n          <nonce> _ </nonce>\n        </account>\n        <account>\n          <acctID> 4 </acctID>\n          <balance> ID_BAL </balance>\n          <code> .WordStack </code>\n          <storage> _:Map </storage>\n          <origStorage> _ </origStorage>\n          <nonce> _ </nonce>\n        </account>\n        <account>\n          <acctID> 5 </acctID>\n          <balance> MODEXP_BAL </balance>\n          <code> .WordStack </code>\n          <storage> _:Map </storage>\n          <origStorage> _ </origStorage>\n          <nonce> _ </nonce>\n        </account>\n        <account>\n          <acctID> 6 </acctID>\n          <balance> ECADD_BAL </balance>\n          <code> .WordStack </code>\n          <storage> _:Map </storage>\n          <origStorage> _ </origStorage>\n          <nonce> _ </nonce>\n        </account>\n        <account>\n          <acctID> 7 </acctID>\n          <balance> ECMUL_BAL </balance>\n          <code> .WordStack </code>\n          <storage> _:Map </storage>\n          <origStorage> _ </origStorage>\n          <nonce> _ </nonce>\n        </account>\n        <account>\n          <acctID> 8 </acctID>\n          <balance> ECPAIRING_BAL </balance>\n          <code> .WordStack </code>\n          <storage> _:Map </storage>\n          <origStorage> _ </origStorage>\n          <nonce> _ </nonce>\n        </account>\n       ... \n      </accounts>\n      <txOrder> _ </txOrder>\n      <txPending> _ </txPending>\n      <messages> _ </messages>\n    </network>\n  </ethereum>\nrequires #rangeAddress(ACCT_ID)\nandBool #notPrecompileAddress(ACCT_ID)\nandBool #rangeAddress(CALLER_ID)\nandBool #rangeAddress(ORIGIN_ID)\nandBool #rangeUInt(256, TIME)\nandBool #rangeUInt(256, ACCT_ID_balance)\nandBool #rangeUInt(256, ECREC_BAL)\nandBool #rangeUInt(256, SHA256_BAL)\nandBool #rangeUInt(256, RIP160_BAL)\nandBool #rangeUInt(256, ID_BAL)\nandBool #rangeUInt(256, MODEXP_BAL)\nandBool #rangeUInt(256, ECADD_BAL)\nandBool #rangeUInt(256, ECMUL_BAL)\nandBool #rangeUInt(256, ECPAIRING_BAL)\nandBool VCallDepth <=Int 1024\nandBool #rangeUInt(256, VCallValue)\n\n  andBool (#rangeAddress(ABI_from)\n  andBool (#rangeAddress(ABI_to)\n  andBool (#rangeUInt(256, ABI_value)\n  andBool (#rangeUInt(256, Approval)\n  andBool (#rangeUInt(256, FromBal)\n  andBool (#rangeUInt(256, ToBal)\n  andBool (#rangeUInt(8, Paused)\n  andBool (#rangeUInt(8, Filler)\n  andBool (#rangeUInt(8, Fillerr)\n  andBool (#rangeAddress(Fillerrr)\n  andBool ((#sizeWordStack(CD) <=Int 1250000000)\n  andBool ((#notPrecompileAddress(Fillerrr))\n  andBool ((ABI_from =/=Int ABI_to)\n  andBool (VGas >=Int 3000000))))))))))))))\n  andBool notBool (\n    (((#rangeUInt(256, FromBal:Int -Int ABI_value:Int)))\n    andBool (((#rangeUInt(256, ToBal:Int +Int ABI_value:Int)))\n    andBool (((#rangeUInt(256, Approval:Int -Int ABI_value:Int)))\n    andBool ((Paused:Int ==Int 0)\n    andBool ((VCallValue:Int ==Int 0)\n    andBool ((ABI_to:Int =/=Int 0)))))))\n  ) \nensures\nFAILURE =/=K EVMC_SUCCESS\n\nendmodule\n","hash":"3172d5ea4d344a7b58795686591b78d8e7ba3328c73d2cd7ff295834b11348d5","status":"????"}],"text":"<div id=\"StandardToken_transferFrom(address,address,uint256)\"><div class=\"codeheader\">\n      <a class=\"anchor\" href=\"#StandardToken_transferFrom(address,address,uint256)\">⚓</a>\n      <a class=\"jumptop\" href=\"#top\">top</a>\n    </div><pre><code>behaviour transferFrom of StandardToken\ninterface transferFrom(address from, address to, uint256 value)\n\ntypes\n  Approval : uint256\n  FromBal  : uint256\n  ToBal    : uint256\n  Paused   : uint8\n  Filler   : uint8\n  Fillerr  : uint8\n  Fillerrr : address\n\nstorage\n  <span class=\"comment\">// </span>\n  balances[from]                 |-> FromBal                                                         => FromBal - value\n  <span class=\"comment\">// </span>\n  balances[to]                   |-> ToBal                                                           => ToBal + value\n  <span class=\"comment\">// </span>\n  approvals[from][CALLER_ID]     |-> Approval                                                        => Approval - value\n  filler_fillerr_paused_fillerrr |-> #WordPackUInt8UInt8UInt8Addr(Filler, Fillerr, Paused, Fillerrr) => #WordPackUInt8UInt8UInt8Addr(Filler, Fillerr, Paused, Fillerrr)\n\niff in range uint256\n  FromBal - value\n  ToBal + value\n  Approval - value\n\niff\n  Paused == 0\n  VCallValue == 0\n  to =/= 0\n\nif\n  from =/= to\n\nreturns 1</code></pre></div>"},{"type":"code","lang":"act","obj":{"isStatic":false,"name":"transfer","subject":"StandardToken","varname2alias":{"ACCT_ID":"StandardToken"},"act_name":"StandardToken_transfer.act","internal":false,"sig":"transfer(address,uint256)","callData":"#abiCallData(\"transfer\", #address(ABI__to), #uint256(ABI__value)) ++ CD","signature":"transfer(address,uint256)","types":{"ABI__to":"address","ABI__value":"uint256","FromBal":"uint256","ToBal":"uint256"},"if":["(#sizeWordStack(CD) <=Int 1250000000)","(FromBal >=Int ABI__value)","(ABI__value >Int 0)","(CALLER_ID =/=Int ABI__to)"],"interface":[["address","_to"],["uint256","_value"]],"fname":"transfer","storage":{"ACCT_ID":{"balances[CALLER_ID]":["FromBal","FromBal - _value"],"balances[_to]":["ToBal  ","ToBal + _value"]}},"iff_orig":["VCallValue == 0"],"iff":["(VCallValue ==Int 0)"],"if_orig":["FromBal >= _value","_value > 0","CALLER_ID =/= _to"],"returns":["1"]},"cases":[{"act":{"isStatic":false,"name":"transfer","subject":"StandardToken","varname2alias":{"ACCT_ID":"StandardToken"},"act_name":"StandardToken_transfer.act","internal":false,"sig":"transfer(address,uint256)","callData":"#abiCallData(\"transfer\", #address(ABI__to), #uint256(ABI__value)) ++ CD","signature":"transfer(address,uint256)","types":{"ABI__to":"address","ABI__value":"uint256","FromBal":"uint256","ToBal":"uint256"},"if":["(#sizeWordStack(CD) <=Int 1250000000)","(FromBal >=Int ABI__value)","(ABI__value >Int 0)","(CALLER_ID =/=Int ABI__to)"],"interface":[["address","_to"],["uint256","_value"]],"fname":"transfer","storage":{"ACCT_ID":{"balances[CALLER_ID]":["FromBal","FromBal - _value"],"balances[_to]":["ToBal  ","ToBal + _value"]}},"iff_orig":["VCallValue == 0"],"iff":["(VCallValue ==Int 0)"],"if_orig":["FromBal >= _value","_value > 0","CALLER_ID =/= _to"],"returns":["1"]},"name":"StandardToken_transfer_pass_rough","pass":true,"rough":true,"oog":false,"splitNumber":-1,"gas":[3000000],"hasGas":false,"spec":"// StandardToken_transfer\nrule [StandardToken.transfer.pass.rough]:\n  <k> #execute ~> CONTINUATION => #halt ~> CONTINUATION </k>\n  <exit-code> 1 </exit-code>\n  <mode> NORMAL </mode>\n  <schedule> PETERSBURG </schedule>\n  <ethereum>\n    <evm>\n      <output> _ => #asByteStackInWidthaux(1, 31, 32, .WordStack) </output>\n      <statusCode> _ => EVMC_SUCCESS </statusCode>\n      <callStack> VCallStack </callStack>\n      <interimStates> _ </interimStates>\n      <touchedAccounts> _ => _ </touchedAccounts>\n      <callState>\n        <program> #asMapOpCodes(#dasmOpCodes(StandardToken_bin_runtime, PETERSBURG)) </program>\n        <programBytes> StandardToken_bin_runtime </programBytes>\n        <id> ACCT_ID </id>\n        <caller> CALLER_ID </caller>\n        <callData> #abiCallData(\"transfer\", #address(ABI__to), #uint256(ABI__value)) ++ CD => _ </callData>\n        <callValue> VCallValue </callValue>\n        <wordStack> .WordStack => _ </wordStack>\n        <localMem> .Map => _ </localMem>\n        <pc> 0 => _ </pc>\n        <gas> VGas => _ </gas>\n        <memoryUsed> 0 => _ </memoryUsed>\n        <callGas> _ => _ </callGas>\n        <static> false </static>\n        <callDepth> VCallDepth </callDepth>\n      </callState>\n      <substate>\n        <selfDestruct> VSelfDestruct </selfDestruct>\n        <log> _ => VLog </log>\n        <refund> _ => VRefund </refund>\n      </substate>\n      <gasPrice> _ </gasPrice>\n      <origin> ORIGIN_ID </origin>\n      <previousHash> _ </previousHash>\n      <ommersHash> _ </ommersHash>\n      <coinbase> _ </coinbase>\n      <stateRoot> _ </stateRoot>\n      <transactionsRoot> _ </transactionsRoot>\n      <receiptsRoot> _ </receiptsRoot>\n      <logsBloom> _ </logsBloom>\n      <difficulty> _ </difficulty>\n      <number> _ </number>\n      <gasLimit> _ </gasLimit>\n      <gasUsed> _ </gasUsed>\n      <timestamp> TIME </timestamp>\n      <extraData> _ </extraData>\n      <mixHash> _ </mixHash>\n      <blockNonce> _ </blockNonce>\n      <ommerBlockHeaders> _ </ommerBlockHeaders>\n      <blockhash> _ </blockhash>\n    </evm>\n    <network>\n      <activeAccounts> SetItem(ACCT_ID)\n      SetItem(1)\n      SetItem(2)\n      SetItem(3)\n      SetItem(4)\n      SetItem(5)\n      SetItem(6)\n      SetItem(7)\n      SetItem(8) _ </activeAccounts>\n      <accounts>\n        <account>\n          <acctID> ACCT_ID </acctID>\n          <balance> ACCT_ID_balance </balance>\n          <code> StandardToken_bin_runtime </code>\n          <storage>         \n           .Map \n          [#StandardToken.balances[CALLER_ID] <- (FromBal => FromBal -Int ABI__value)]        \n          [#StandardToken.balances[ABI__to] <- (ToBal   => ToBal +Int ABI__value)]\n            _:Map \n           </storage>\n          <origStorage> _ </origStorage>\n          <nonce> _ </nonce>\n        </account>\n        <account>\n          <acctID> 1 </acctID>\n          <balance> ECREC_BAL </balance>\n          <code> .WordStack </code>\n          <storage> _:Map </storage>\n          <origStorage> _ </origStorage>\n          <nonce> _ </nonce>\n        </account>\n        <account>\n          <acctID> 2 </acctID>\n          <balance> SHA256_BAL </balance>\n          <code> .WordStack </code>\n          <storage> _:Map </storage>\n          <origStorage> _ </origStorage>\n          <nonce> _ </nonce>\n        </account>\n        <account>\n          <acctID> 3 </acctID>\n          <balance> RIP160_BAL </balance>\n          <code> .WordStack </code>\n          <storage> _:Map </storage>\n          <origStorage> _ </origStorage>\n          <nonce> _ </nonce>\n        </account>\n        <account>\n          <acctID> 4 </acctID>\n          <balance> ID_BAL </balance>\n          <code> .WordStack </code>\n          <storage> _:Map </storage>\n          <origStorage> _ </origStorage>\n          <nonce> _ </nonce>\n        </account>\n        <account>\n          <acctID> 5 </acctID>\n          <balance> MODEXP_BAL </balance>\n          <code> .WordStack </code>\n          <storage> _:Map </storage>\n          <origStorage> _ </origStorage>\n          <nonce> _ </nonce>\n        </account>\n        <account>\n          <acctID> 6 </acctID>\n          <balance> ECADD_BAL </balance>\n          <code> .WordStack </code>\n          <storage> _:Map </storage>\n          <origStorage> _ </origStorage>\n          <nonce> _ </nonce>\n        </account>\n        <account>\n          <acctID> 7 </acctID>\n          <balance> ECMUL_BAL </balance>\n          <code> .WordStack </code>\n          <storage> _:Map </storage>\n          <origStorage> _ </origStorage>\n          <nonce> _ </nonce>\n        </account>\n        <account>\n          <acctID> 8 </acctID>\n          <balance> ECPAIRING_BAL </balance>\n          <code> .WordStack </code>\n          <storage> _:Map </storage>\n          <origStorage> _ </origStorage>\n          <nonce> _ </nonce>\n        </account>\n       ... \n      </accounts>\n      <txOrder> _ </txOrder>\n      <txPending> _ </txPending>\n      <messages> _ </messages>\n    </network>\n  </ethereum>\nrequires #rangeAddress(ACCT_ID)\nandBool #notPrecompileAddress(ACCT_ID)\nandBool #rangeAddress(CALLER_ID)\nandBool #rangeAddress(ORIGIN_ID)\nandBool #rangeUInt(256, TIME)\nandBool #rangeUInt(256, ACCT_ID_balance)\nandBool #rangeUInt(256, ECREC_BAL)\nandBool #rangeUInt(256, SHA256_BAL)\nandBool #rangeUInt(256, RIP160_BAL)\nandBool #rangeUInt(256, ID_BAL)\nandBool #rangeUInt(256, MODEXP_BAL)\nandBool #rangeUInt(256, ECADD_BAL)\nandBool #rangeUInt(256, ECMUL_BAL)\nandBool #rangeUInt(256, ECPAIRING_BAL)\nandBool VCallDepth <=Int 1024\nandBool #rangeUInt(256, VCallValue)\n\n  andBool (#rangeAddress(ABI__to)\n  andBool (#rangeUInt(256, ABI__value)\n  andBool (#rangeUInt(256, FromBal)\n  andBool (#rangeUInt(256, ToBal)\n  andBool ((#sizeWordStack(CD) <=Int 1250000000)\n  andBool ((FromBal >=Int ABI__value)\n  andBool ((ABI__value >Int 0)\n  andBool ((CALLER_ID =/=Int ABI__to)\n  andBool (VGas >=Int 3000000\n  andBool ((VCallValue ==Int 0))))))))))) ","v2n":{"ACCT_ID":"StandardToken"},"act_name":"StandardToken_transfer.act","imports":[],"closed":true,"ctx":[],"module":"requires \"../rules.k\"\nrequires \"../bin_runtime.k\"\n\nmodule 6D5DE197ADB35640093EB293774149E0787659D0243C7924D5695C822D2E1840\n  imports ETHEREUM-SIMULATION\n  imports EVM\n  imports RULES\n  imports BIN_RUNTIME\n\n// StandardToken_transfer\nrule [StandardToken.transfer.pass.rough]:\n  <k> #execute ~> CONTINUATION => #halt ~> CONTINUATION </k>\n  <exit-code> 1 </exit-code>\n  <mode> NORMAL </mode>\n  <schedule> PETERSBURG </schedule>\n  <ethereum>\n    <evm>\n      <output> _ => #asByteStackInWidthaux(1, 31, 32, .WordStack) </output>\n      <statusCode> _ => EVMC_SUCCESS </statusCode>\n      <callStack> VCallStack </callStack>\n      <interimStates> _ </interimStates>\n      <touchedAccounts> _ => _ </touchedAccounts>\n      <callState>\n        <program> #asMapOpCodes(#dasmOpCodes(StandardToken_bin_runtime, PETERSBURG)) </program>\n        <programBytes> StandardToken_bin_runtime </programBytes>\n        <id> ACCT_ID </id>\n        <caller> CALLER_ID </caller>\n        <callData> #abiCallData(\"transfer\", #address(ABI__to), #uint256(ABI__value)) ++ CD => _ </callData>\n        <callValue> VCallValue </callValue>\n        <wordStack> .WordStack => _ </wordStack>\n        <localMem> .Map => _ </localMem>\n        <pc> 0 => _ </pc>\n        <gas> VGas => _ </gas>\n        <memoryUsed> 0 => _ </memoryUsed>\n        <callGas> _ => _ </callGas>\n        <static> false </static>\n        <callDepth> VCallDepth </callDepth>\n      </callState>\n      <substate>\n        <selfDestruct> VSelfDestruct </selfDestruct>\n        <log> _ => VLog </log>\n        <refund> _ => VRefund </refund>\n      </substate>\n      <gasPrice> _ </gasPrice>\n      <origin> ORIGIN_ID </origin>\n      <previousHash> _ </previousHash>\n      <ommersHash> _ </ommersHash>\n      <coinbase> _ </coinbase>\n      <stateRoot> _ </stateRoot>\n      <transactionsRoot> _ </transactionsRoot>\n      <receiptsRoot> _ </receiptsRoot>\n      <logsBloom> _ </logsBloom>\n      <difficulty> _ </difficulty>\n      <number> _ </number>\n      <gasLimit> _ </gasLimit>\n      <gasUsed> _ </gasUsed>\n      <timestamp> TIME </timestamp>\n      <extraData> _ </extraData>\n      <mixHash> _ </mixHash>\n      <blockNonce> _ </blockNonce>\n      <ommerBlockHeaders> _ </ommerBlockHeaders>\n      <blockhash> _ </blockhash>\n    </evm>\n    <network>\n      <activeAccounts> SetItem(ACCT_ID)\n      SetItem(1)\n      SetItem(2)\n      SetItem(3)\n      SetItem(4)\n      SetItem(5)\n      SetItem(6)\n      SetItem(7)\n      SetItem(8) _ </activeAccounts>\n      <accounts>\n        <account>\n          <acctID> ACCT_ID </acctID>\n          <balance> ACCT_ID_balance </balance>\n          <code> StandardToken_bin_runtime </code>\n          <storage>         \n           .Map \n          [#StandardToken.balances[CALLER_ID] <- (FromBal => FromBal -Int ABI__value)]        \n          [#StandardToken.balances[ABI__to] <- (ToBal   => ToBal +Int ABI__value)]\n            _:Map \n           </storage>\n          <origStorage> _ </origStorage>\n          <nonce> _ </nonce>\n        </account>\n        <account>\n          <acctID> 1 </acctID>\n          <balance> ECREC_BAL </balance>\n          <code> .WordStack </code>\n          <storage> _:Map </storage>\n          <origStorage> _ </origStorage>\n          <nonce> _ </nonce>\n        </account>\n        <account>\n          <acctID> 2 </acctID>\n          <balance> SHA256_BAL </balance>\n          <code> .WordStack </code>\n          <storage> _:Map </storage>\n          <origStorage> _ </origStorage>\n          <nonce> _ </nonce>\n        </account>\n        <account>\n          <acctID> 3 </acctID>\n          <balance> RIP160_BAL </balance>\n          <code> .WordStack </code>\n          <storage> _:Map </storage>\n          <origStorage> _ </origStorage>\n          <nonce> _ </nonce>\n        </account>\n        <account>\n          <acctID> 4 </acctID>\n          <balance> ID_BAL </balance>\n          <code> .WordStack </code>\n          <storage> _:Map </storage>\n          <origStorage> _ </origStorage>\n          <nonce> _ </nonce>\n        </account>\n        <account>\n          <acctID> 5 </acctID>\n          <balance> MODEXP_BAL </balance>\n          <code> .WordStack </code>\n          <storage> _:Map </storage>\n          <origStorage> _ </origStorage>\n          <nonce> _ </nonce>\n        </account>\n        <account>\n          <acctID> 6 </acctID>\n          <balance> ECADD_BAL </balance>\n          <code> .WordStack </code>\n          <storage> _:Map </storage>\n          <origStorage> _ </origStorage>\n          <nonce> _ </nonce>\n        </account>\n        <account>\n          <acctID> 7 </acctID>\n          <balance> ECMUL_BAL </balance>\n          <code> .WordStack </code>\n          <storage> _:Map </storage>\n          <origStorage> _ </origStorage>\n          <nonce> _ </nonce>\n        </account>\n        <account>\n          <acctID> 8 </acctID>\n          <balance> ECPAIRING_BAL </balance>\n          <code> .WordStack </code>\n          <storage> _:Map </storage>\n          <origStorage> _ </origStorage>\n          <nonce> _ </nonce>\n        </account>\n       ... \n      </accounts>\n      <txOrder> _ </txOrder>\n      <txPending> _ </txPending>\n      <messages> _ </messages>\n    </network>\n  </ethereum>\nrequires #rangeAddress(ACCT_ID)\nandBool #notPrecompileAddress(ACCT_ID)\nandBool #rangeAddress(CALLER_ID)\nandBool #rangeAddress(ORIGIN_ID)\nandBool #rangeUInt(256, TIME)\nandBool #rangeUInt(256, ACCT_ID_balance)\nandBool #rangeUInt(256, ECREC_BAL)\nandBool #rangeUInt(256, SHA256_BAL)\nandBool #rangeUInt(256, RIP160_BAL)\nandBool #rangeUInt(256, ID_BAL)\nandBool #rangeUInt(256, MODEXP_BAL)\nandBool #rangeUInt(256, ECADD_BAL)\nandBool #rangeUInt(256, ECMUL_BAL)\nandBool #rangeUInt(256, ECPAIRING_BAL)\nandBool VCallDepth <=Int 1024\nandBool #rangeUInt(256, VCallValue)\n\n  andBool (#rangeAddress(ABI__to)\n  andBool (#rangeUInt(256, ABI__value)\n  andBool (#rangeUInt(256, FromBal)\n  andBool (#rangeUInt(256, ToBal)\n  andBool ((#sizeWordStack(CD) <=Int 1250000000)\n  andBool ((FromBal >=Int ABI__value)\n  andBool ((ABI__value >Int 0)\n  andBool ((CALLER_ID =/=Int ABI__to)\n  andBool (VGas >=Int 3000000\n  andBool ((VCallValue ==Int 0))))))))))) \n\nendmodule\n","hash":"6d5de197adb35640093eb293774149e0787659d0243c7924d5695c822d2e1840","status":"reject"},{"act":{"isStatic":false,"name":"transfer","subject":"StandardToken","varname2alias":{"ACCT_ID":"StandardToken"},"act_name":"StandardToken_transfer.act","internal":false,"sig":"transfer(address,uint256)","callData":"#abiCallData(\"transfer\", #address(ABI__to), #uint256(ABI__value)) ++ CD","signature":"transfer(address,uint256)","types":{"ABI__to":"address","ABI__value":"uint256","FromBal":"uint256","ToBal":"uint256"},"if":["(#sizeWordStack(CD) <=Int 1250000000)","(FromBal >=Int ABI__value)","(ABI__value >Int 0)","(CALLER_ID =/=Int ABI__to)"],"interface":[["address","_to"],["uint256","_value"]],"fname":"transfer","storage":{"ACCT_ID":{"balances[CALLER_ID]":["FromBal","FromBal - _value"],"balances[_to]":["ToBal  ","ToBal + _value"]}},"iff_orig":["VCallValue == 0"],"iff":["(VCallValue ==Int 0)"],"if_orig":["FromBal >= _value","_value > 0","CALLER_ID =/= _to"],"returns":["1"],"ensures":["FAILURE =/=K EVMC_SUCCESS"]},"pass":false,"splitNumber":-1,"gas":3000000,"oog":false,"name":"StandardToken_transfer_fail_rough","spec":"// StandardToken_transfer\nrule [StandardToken.transfer.fail.rough]:\n  <k> #execute ~> CONTINUATION => #halt ~> CONTINUATION </k>\n  <exit-code> 1 </exit-code>\n  <mode> NORMAL </mode>\n  <schedule> PETERSBURG </schedule>\n  <ethereum>\n    <evm>\n      <output> _ => _ </output>\n      <statusCode> _ => FAILURE:EndStatusCode </statusCode>\n      <callStack> VCallStack </callStack>\n      <interimStates> _ </interimStates>\n      <touchedAccounts> _ => _ </touchedAccounts>\n      <callState>\n        <program> #asMapOpCodes(#dasmOpCodes(StandardToken_bin_runtime, PETERSBURG)) </program>\n        <programBytes> StandardToken_bin_runtime </programBytes>\n        <id> ACCT_ID </id>\n        <caller> CALLER_ID </caller>\n        <callData> #abiCallData(\"transfer\", #address(ABI__to), #uint256(ABI__value)) ++ CD => _ </callData>\n        <callValue> VCallValue </callValue>\n        <wordStack> .WordStack => _ </wordStack>\n        <localMem> .Map => _ </localMem>\n        <pc> 0 => _ </pc>\n        <gas> VGas => _ </gas>\n        <memoryUsed> 0 => _ </memoryUsed>\n        <callGas> _ => _ </callGas>\n        <static> false </static>\n        <callDepth> VCallDepth => _ </callDepth>\n      </callState>\n      <substate>\n        <selfDestruct> VSelfDestruct </selfDestruct>\n        <log> _ => VLog </log>\n        <refund> _ => VRefund </refund>\n      </substate>\n      <gasPrice> _ </gasPrice>\n      <origin> ORIGIN_ID </origin>\n      <previousHash> _ </previousHash>\n      <ommersHash> _ </ommersHash>\n      <coinbase> _ </coinbase>\n      <stateRoot> _ </stateRoot>\n      <transactionsRoot> _ </transactionsRoot>\n      <receiptsRoot> _ </receiptsRoot>\n      <logsBloom> _ </logsBloom>\n      <difficulty> _ </difficulty>\n      <number> _ </number>\n      <gasLimit> _ </gasLimit>\n      <gasUsed> _ </gasUsed>\n      <timestamp> TIME </timestamp>\n      <extraData> _ </extraData>\n      <mixHash> _ </mixHash>\n      <blockNonce> _ </blockNonce>\n      <ommerBlockHeaders> _ </ommerBlockHeaders>\n      <blockhash> _ </blockhash>\n    </evm>\n    <network>\n      <activeAccounts> SetItem(ACCT_ID)\n      SetItem(1)\n      SetItem(2)\n      SetItem(3)\n      SetItem(4)\n      SetItem(5)\n      SetItem(6)\n      SetItem(7)\n      SetItem(8) _ </activeAccounts>\n      <accounts>\n        <account>\n          <acctID> ACCT_ID </acctID>\n          <balance> ACCT_ID_balance </balance>\n          <code> StandardToken_bin_runtime </code>\n          <storage>         \n           .Map \n          [#StandardToken.balances[CALLER_ID] <- (FromBal => _)]        \n          [#StandardToken.balances[ABI__to] <- (ToBal   => _)]\n            _:Map \n           </storage>\n          <origStorage> _ </origStorage>\n          <nonce> _ </nonce>\n        </account>\n        <account>\n          <acctID> 1 </acctID>\n          <balance> ECREC_BAL </balance>\n          <code> .WordStack </code>\n          <storage> _:Map </storage>\n          <origStorage> _ </origStorage>\n          <nonce> _ </nonce>\n        </account>\n        <account>\n          <acctID> 2 </acctID>\n          <balance> SHA256_BAL </balance>\n          <code> .WordStack </code>\n          <storage> _:Map </storage>\n          <origStorage> _ </origStorage>\n          <nonce> _ </nonce>\n        </account>\n        <account>\n          <acctID> 3 </acctID>\n          <balance> RIP160_BAL </balance>\n          <code> .WordStack </code>\n          <storage> _:Map </storage>\n          <origStorage> _ </origStorage>\n          <nonce> _ </nonce>\n        </account>\n        <account>\n          <acctID> 4 </acctID>\n          <balance> ID_BAL </balance>\n          <code> .WordStack </code>\n          <storage> _:Map </storage>\n          <origStorage> _ </origStorage>\n          <nonce> _ </nonce>\n        </account>\n        <account>\n          <acctID> 5 </acctID>\n          <balance> MODEXP_BAL </balance>\n          <code> .WordStack </code>\n          <storage> _:Map </storage>\n          <origStorage> _ </origStorage>\n          <nonce> _ </nonce>\n        </account>\n        <account>\n          <acctID> 6 </acctID>\n          <balance> ECADD_BAL </balance>\n          <code> .WordStack </code>\n          <storage> _:Map </storage>\n          <origStorage> _ </origStorage>\n          <nonce> _ </nonce>\n        </account>\n        <account>\n          <acctID> 7 </acctID>\n          <balance> ECMUL_BAL </balance>\n          <code> .WordStack </code>\n          <storage> _:Map </storage>\n          <origStorage> _ </origStorage>\n          <nonce> _ </nonce>\n        </account>\n        <account>\n          <acctID> 8 </acctID>\n          <balance> ECPAIRING_BAL </balance>\n          <code> .WordStack </code>\n          <storage> _:Map </storage>\n          <origStorage> _ </origStorage>\n          <nonce> _ </nonce>\n        </account>\n       ... \n      </accounts>\n      <txOrder> _ </txOrder>\n      <txPending> _ </txPending>\n      <messages> _ </messages>\n    </network>\n  </ethereum>\nrequires #rangeAddress(ACCT_ID)\nandBool #notPrecompileAddress(ACCT_ID)\nandBool #rangeAddress(CALLER_ID)\nandBool #rangeAddress(ORIGIN_ID)\nandBool #rangeUInt(256, TIME)\nandBool #rangeUInt(256, ACCT_ID_balance)\nandBool #rangeUInt(256, ECREC_BAL)\nandBool #rangeUInt(256, SHA256_BAL)\nandBool #rangeUInt(256, RIP160_BAL)\nandBool #rangeUInt(256, ID_BAL)\nandBool #rangeUInt(256, MODEXP_BAL)\nandBool #rangeUInt(256, ECADD_BAL)\nandBool #rangeUInt(256, ECMUL_BAL)\nandBool #rangeUInt(256, ECPAIRING_BAL)\nandBool VCallDepth <=Int 1024\nandBool #rangeUInt(256, VCallValue)\n\n  andBool (#rangeAddress(ABI__to)\n  andBool (#rangeUInt(256, ABI__value)\n  andBool (#rangeUInt(256, FromBal)\n  andBool (#rangeUInt(256, ToBal)\n  andBool ((#sizeWordStack(CD) <=Int 1250000000)\n  andBool ((FromBal >=Int ABI__value)\n  andBool ((ABI__value >Int 0)\n  andBool ((CALLER_ID =/=Int ABI__to)\n  andBool (VGas >=Int 3000000)))))))))\n  andBool notBool (\n    ((VCallValue:Int ==Int 0))\n  ) \nensures\nFAILURE =/=K EVMC_SUCCESS","v2n":{"ACCT_ID":"StandardToken"},"act_name":"StandardToken_transfer.act","imports":[],"closed":true,"ctx":[],"module":"requires \"../rules.k\"\nrequires \"../bin_runtime.k\"\n\nmodule 85E7D48A032F31F086651E74197EFF4BA347072BCE2BE140A5F995A69C164C78\n  imports ETHEREUM-SIMULATION\n  imports EVM\n  imports RULES\n  imports BIN_RUNTIME\n\n// StandardToken_transfer\nrule [StandardToken.transfer.fail.rough]:\n  <k> #execute ~> CONTINUATION => #halt ~> CONTINUATION </k>\n  <exit-code> 1 </exit-code>\n  <mode> NORMAL </mode>\n  <schedule> PETERSBURG </schedule>\n  <ethereum>\n    <evm>\n      <output> _ => _ </output>\n      <statusCode> _ => FAILURE:EndStatusCode </statusCode>\n      <callStack> VCallStack </callStack>\n      <interimStates> _ </interimStates>\n      <touchedAccounts> _ => _ </touchedAccounts>\n      <callState>\n        <program> #asMapOpCodes(#dasmOpCodes(StandardToken_bin_runtime, PETERSBURG)) </program>\n        <programBytes> StandardToken_bin_runtime </programBytes>\n        <id> ACCT_ID </id>\n        <caller> CALLER_ID </caller>\n        <callData> #abiCallData(\"transfer\", #address(ABI__to), #uint256(ABI__value)) ++ CD => _ </callData>\n        <callValue> VCallValue </callValue>\n        <wordStack> .WordStack => _ </wordStack>\n        <localMem> .Map => _ </localMem>\n        <pc> 0 => _ </pc>\n        <gas> VGas => _ </gas>\n        <memoryUsed> 0 => _ </memoryUsed>\n        <callGas> _ => _ </callGas>\n        <static> false </static>\n        <callDepth> VCallDepth => _ </callDepth>\n      </callState>\n      <substate>\n        <selfDestruct> VSelfDestruct </selfDestruct>\n        <log> _ => VLog </log>\n        <refund> _ => VRefund </refund>\n      </substate>\n      <gasPrice> _ </gasPrice>\n      <origin> ORIGIN_ID </origin>\n      <previousHash> _ </previousHash>\n      <ommersHash> _ </ommersHash>\n      <coinbase> _ </coinbase>\n      <stateRoot> _ </stateRoot>\n      <transactionsRoot> _ </transactionsRoot>\n      <receiptsRoot> _ </receiptsRoot>\n      <logsBloom> _ </logsBloom>\n      <difficulty> _ </difficulty>\n      <number> _ </number>\n      <gasLimit> _ </gasLimit>\n      <gasUsed> _ </gasUsed>\n      <timestamp> TIME </timestamp>\n      <extraData> _ </extraData>\n      <mixHash> _ </mixHash>\n      <blockNonce> _ </blockNonce>\n      <ommerBlockHeaders> _ </ommerBlockHeaders>\n      <blockhash> _ </blockhash>\n    </evm>\n    <network>\n      <activeAccounts> SetItem(ACCT_ID)\n      SetItem(1)\n      SetItem(2)\n      SetItem(3)\n      SetItem(4)\n      SetItem(5)\n      SetItem(6)\n      SetItem(7)\n      SetItem(8) _ </activeAccounts>\n      <accounts>\n        <account>\n          <acctID> ACCT_ID </acctID>\n          <balance> ACCT_ID_balance </balance>\n          <code> StandardToken_bin_runtime </code>\n          <storage>         \n           .Map \n          [#StandardToken.balances[CALLER_ID] <- (FromBal => _)]        \n          [#StandardToken.balances[ABI__to] <- (ToBal   => _)]\n            _:Map \n           </storage>\n          <origStorage> _ </origStorage>\n          <nonce> _ </nonce>\n        </account>\n        <account>\n          <acctID> 1 </acctID>\n          <balance> ECREC_BAL </balance>\n          <code> .WordStack </code>\n          <storage> _:Map </storage>\n          <origStorage> _ </origStorage>\n          <nonce> _ </nonce>\n        </account>\n        <account>\n          <acctID> 2 </acctID>\n          <balance> SHA256_BAL </balance>\n          <code> .WordStack </code>\n          <storage> _:Map </storage>\n          <origStorage> _ </origStorage>\n          <nonce> _ </nonce>\n        </account>\n        <account>\n          <acctID> 3 </acctID>\n          <balance> RIP160_BAL </balance>\n          <code> .WordStack </code>\n          <storage> _:Map </storage>\n          <origStorage> _ </origStorage>\n          <nonce> _ </nonce>\n        </account>\n        <account>\n          <acctID> 4 </acctID>\n          <balance> ID_BAL </balance>\n          <code> .WordStack </code>\n          <storage> _:Map </storage>\n          <origStorage> _ </origStorage>\n          <nonce> _ </nonce>\n        </account>\n        <account>\n          <acctID> 5 </acctID>\n          <balance> MODEXP_BAL </balance>\n          <code> .WordStack </code>\n          <storage> _:Map </storage>\n          <origStorage> _ </origStorage>\n          <nonce> _ </nonce>\n        </account>\n        <account>\n          <acctID> 6 </acctID>\n          <balance> ECADD_BAL </balance>\n          <code> .WordStack </code>\n          <storage> _:Map </storage>\n          <origStorage> _ </origStorage>\n          <nonce> _ </nonce>\n        </account>\n        <account>\n          <acctID> 7 </acctID>\n          <balance> ECMUL_BAL </balance>\n          <code> .WordStack </code>\n          <storage> _:Map </storage>\n          <origStorage> _ </origStorage>\n          <nonce> _ </nonce>\n        </account>\n        <account>\n          <acctID> 8 </acctID>\n          <balance> ECPAIRING_BAL </balance>\n          <code> .WordStack </code>\n          <storage> _:Map </storage>\n          <origStorage> _ </origStorage>\n          <nonce> _ </nonce>\n        </account>\n       ... \n      </accounts>\n      <txOrder> _ </txOrder>\n      <txPending> _ </txPending>\n      <messages> _ </messages>\n    </network>\n  </ethereum>\nrequires #rangeAddress(ACCT_ID)\nandBool #notPrecompileAddress(ACCT_ID)\nandBool #rangeAddress(CALLER_ID)\nandBool #rangeAddress(ORIGIN_ID)\nandBool #rangeUInt(256, TIME)\nandBool #rangeUInt(256, ACCT_ID_balance)\nandBool #rangeUInt(256, ECREC_BAL)\nandBool #rangeUInt(256, SHA256_BAL)\nandBool #rangeUInt(256, RIP160_BAL)\nandBool #rangeUInt(256, ID_BAL)\nandBool #rangeUInt(256, MODEXP_BAL)\nandBool #rangeUInt(256, ECADD_BAL)\nandBool #rangeUInt(256, ECMUL_BAL)\nandBool #rangeUInt(256, ECPAIRING_BAL)\nandBool VCallDepth <=Int 1024\nandBool #rangeUInt(256, VCallValue)\n\n  andBool (#rangeAddress(ABI__to)\n  andBool (#rangeUInt(256, ABI__value)\n  andBool (#rangeUInt(256, FromBal)\n  andBool (#rangeUInt(256, ToBal)\n  andBool ((#sizeWordStack(CD) <=Int 1250000000)\n  andBool ((FromBal >=Int ABI__value)\n  andBool ((ABI__value >Int 0)\n  andBool ((CALLER_ID =/=Int ABI__to)\n  andBool (VGas >=Int 3000000)))))))))\n  andBool notBool (\n    ((VCallValue:Int ==Int 0))\n  ) \nensures\nFAILURE =/=K EVMC_SUCCESS\n\nendmodule\n","hash":"85e7d48a032f31f086651e74197eff4ba347072bce2be140a5f995a69c164c78","status":"????"}],"text":"<div id=\"StandardToken_transfer(address,uint256)\"><div class=\"codeheader\">\n      <a class=\"anchor\" href=\"#StandardToken_transfer(address,uint256)\">⚓</a>\n      <a class=\"jumptop\" href=\"#top\">top</a>\n    </div><pre><code>behaviour transfer of StandardToken\ninterface transfer(address _to, uint256 _value)\n\ntypes\n  FromBal : uint256\n  ToBal   : uint256\n\nstorage\n  <span class=\"comment\">// </span>\n  balances[CALLER_ID] |-> FromBal => FromBal - _value\n  <span class=\"comment\">// </span>\n  balances[_to]       |-> ToBal   => ToBal + _value\n\niff\n  VCallValue == 0\n\nif\n  FromBal >= _value\n  _value > 0\n  CALLER_ID =/= _to\n\nreturns 1 </code></pre></div>"}]